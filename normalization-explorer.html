<!doctype html>
<html lang="en" style="scroll-behavior: smooth;">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Normalization Explorer - Scorecard Playground</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="cache-version.js?v=1.0.3"></script>
  <script src="scorecard-config.js?v=1.0.3"></script>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #111935;
      --panel2: #0f1730;
      --text: #e9eefc;
      --muted: #a9b4d6;
      --border: rgba(255,255,255,.10);
      --good: #6ee7b7;
      --warn: #fde68a;
      --bad: #fb7185;
      --accent: #93c5fd;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 10% 10%, rgba(147,197,253,.14), transparent),
                  radial-gradient(1000px 600px at 90% 20%, rgba(110,231,183,.10), transparent),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 40px 20px;
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 20px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 24px;
    }

    h1 {
      margin: 0;
      font-size: 26px;
      letter-spacing: .2px;
    }

    .sub {
      color: var(--muted);
      font-size: 14px;
      max-width: 66ch;
      line-height: 1.5;
      margin-top: 8px;
    }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: var(--accent);
      text-decoration: none;
      font-size: 13px;
      font-weight: 600;
      padding: 8px 14px;
      background: rgba(147,197,253,.12);
      border: 1px solid rgba(147,197,253,.25);
      border-radius: 8px;
      transition: background .15s, border-color .15s;
    }

    .back-link:hover {
      background: rgba(147,197,253,.20);
      border-color: rgba(147,197,253,.40);
    }

    .grid {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,.30);
    }

    .card h2 {
      margin: 0 0 16px;
      font-size: 16px;
      color: var(--text);
      font-weight: 700;
      letter-spacing: .2px;
    }

    .card h3 {
      margin: 0 0 12px;
      font-size: 14px;
      color: var(--muted);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: .2px;
    }

    .intro-box {
      background: linear-gradient(135deg, rgba(147,197,253,.08), rgba(110,231,183,.05));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px 24px;
      margin-bottom: 20px;
      line-height: 1.6;
    }
    .intro-box h3 {
      margin: 0 0 12px;
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
      text-transform: none;
    }
    .intro-box p {
      margin: 0 0 12px;
      font-size: 14px;
      color: var(--text);
    }
    .intro-box p:last-child {
      margin-bottom: 0;
    }
    .intro-box ul {
      margin: 0;
      padding-left: 20px;
      font-size: 14px;
      color: var(--text);
    }
    .intro-box li {
      margin-bottom: 8px;
    }
    .intro-box li:last-child {
      margin-bottom: 0;
    }
    .intro-box strong {
      color: var(--accent);
    }
    .intro-box em {
      color: var(--good);
      font-style: normal;
    }

    .muted { color: var(--muted); }
    .mono { font-family: var(--mono); }
    .small { font-size: 12px; }

    label {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    input[type="number"], select {
      background: rgba(0,0,0,.22);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }

    input[type="number"] { width: 80px; }
    select { padding: 8px 10px; }

    .row {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items: center;
    }

    .config-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .config-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: .2px;
    }

    /* Method selector tabs */
    .method-tabs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 20px;
    }

    .method-tab {
      padding: 10px 16px;
      background: rgba(255,255,255,.06);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--muted);
      font-size: 13px;
      font-weight: 600;
      cursor: pointer;
      transition: all .15s;
    }

    .method-tab:hover {
      background: rgba(255,255,255,.10);
      color: var(--text);
    }

    .method-tab.active {
      background: rgba(147,197,253,.16);
      border-color: rgba(147,197,253,.35);
      color: var(--accent);
    }

    .method-tab .color-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 8px;
      vertical-align: middle;
    }

    /* Method details panel */
    .method-details {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 768px) {
      .method-details {
        grid-template-columns: 1fr;
      }
    }

    .method-info {
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }

    .method-info h4 {
      margin: 0 0 10px;
      font-size: 14px;
      color: var(--text);
      font-weight: 600;
    }

    .method-info p {
      margin: 0 0 12px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.5;
    }

    .method-info p:last-child {
      margin-bottom: 0;
    }

    .formula-box {
      background: rgba(0,0,0,.25);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
      font-family: var(--mono);
      font-size: 14px;
      color: var(--accent);
      margin: 12px 0;
    }

    .examples-box {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
    }

    /* Parameter controls */
    .params-panel {
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }

    .param-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .param-row:last-child {
      margin-bottom: 0;
    }

    .param-label {
      min-width: 100px;
      font-size: 13px;
      color: var(--muted);
    }

    .param-desc {
      font-size: 11px;
      color: var(--muted);
      opacity: 0.8;
    }

    /* Chart container */
    .chart-container {
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-top: 20px;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .chart-title {
      font-size: 13px;
      color: var(--muted);
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: .2px;
    }

    .chart-controls {
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .chart-wrap {
      position: relative;
      height: 300px;
    }

    /* Comparison table */
    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      margin-top: 16px;
    }

    .comparison-table th {
      text-align: left;
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
      font-weight: 600;
    }

    .comparison-table th.right {
      text-align: right;
    }

    .comparison-table td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      vertical-align: middle;
    }

    .comparison-table td.mono {
      font-family: var(--mono);
    }

    .comparison-table td.right {
      text-align: right;
    }

    .comparison-table tr:last-child td {
      border-bottom: none;
    }

    .comparison-table .method-name {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .comparison-table .method-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    /* Score badges */
    .score-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 6px;
      font-family: var(--mono);
      font-size: 12px;
      font-weight: 600;
    }

    .score-good { 
      background: rgba(110,231,183,.18); 
      color: var(--good); 
    }
    .score-warn { 
      background: rgba(253,230,138,.18); 
      color: var(--warn); 
    }
    .score-bad { 
      background: rgba(251,113,133,.18); 
      color: var(--bad); 
    }

    /* Use case cards */
    .use-cases {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }

    .use-case {
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
    }

    .use-case h4 {
      margin: 0 0 8px;
      font-size: 13px;
      color: var(--accent);
      font-weight: 600;
    }

    .use-case p {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }

    /* Pro/con tags */
    .pros-cons {
      display: flex;
      gap: 20px;
      margin-top: 12px;
    }

    .pros, .cons {
      flex: 1;
    }

    .pros h5, .cons h5 {
      margin: 0 0 8px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .5px;
      font-weight: 600;
    }

    .pros h5 { color: var(--good); }
    .cons h5 { color: var(--bad); }

    .pros ul, .cons ul {
      margin: 0;
      padding-left: 16px;
      font-size: 12px;
      color: var(--muted);
    }

    .pros li, .cons li {
      margin-bottom: 4px;
    }

    /* Interactive test section */
    .test-section {
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-top: 20px;
    }

    .test-input {
      display: flex;
      gap: 16px;
      align-items: center;
      flex-wrap: wrap;
    }

    .test-result {
      display: flex;
      gap: 20px;
      margin-top: 16px;
      flex-wrap: wrap;
    }

    .result-card {
      flex: 1;
      min-width: 120px;
      background: rgba(255,255,255,.04);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }

    .result-card .label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
      margin-bottom: 4px;
    }

    .result-card .value {
      font-family: var(--mono);
      font-size: 18px;
      font-weight: 700;
    }

    .result-card .method-name-small {
      font-size: 10px;
      color: var(--muted);
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <a href="index.html" class="back-link">← Back to Scorecard</a>
        <h1 style="margin-top: 16px;">Normalization Explorer</h1>
        <p class="sub">
          Explore and compare the different normalization methods used to convert raw counts 
          (vulnerabilities, bugs, etc.) into 0–1 scores for the scorecard.
        </p>
      </div>
    </header>

    <div class="grid">
      <!-- Introduction -->
      <div class="intro-box">
        <h3>What is normalization?</h3>
        <p>
          <strong>Normalization</strong> is the process of converting raw counts (like vulnerability counts or bug counts) 
          into a standardized <em>0–1 score</em>. This allows us to compare and aggregate different types of metrics 
          into a unified scorecard.
        </p>
        <p>
          Different normalization methods have different characteristics—some are more forgiving of initial issues, 
          others provide hard cutoffs, and some model diminishing returns. The right choice depends on your team's 
          goals and how you want to incentivize behavior.
        </p>
      </div>

      <!-- Method Selector -->
      <div class="card">
        <h2>Select a Method to Explore</h2>
        <div class="method-tabs" id="methodTabs">
          <!-- Populated by JavaScript -->
        </div>

        <div class="method-details">
          <div class="method-info" id="methodInfo">
            <!-- Populated by JavaScript -->
          </div>
          <div class="params-panel" id="paramsPanel">
            <!-- Populated by JavaScript -->
          </div>
        </div>

        <!-- Interactive Test -->
        <div class="test-section">
          <h3>Test a Value</h3>
          <div class="test-input">
            <label>
              Count:
              <input type="number" id="testCount" min="0" value="5" step="1" />
            </label>
            <span class="muted small">Enter a count value to see how each method normalizes it</span>
          </div>
          <div class="test-result" id="testResults">
            <!-- Populated by JavaScript -->
          </div>
        </div>

        <!-- Individual Method Chart -->
        <div class="chart-container">
          <div class="chart-header">
            <span class="chart-title">Normalization Curve</span>
            <div class="chart-controls">
              <label style="font-size: 12px;">
                <input type="checkbox" id="showAllMethods" /> Compare all methods
              </label>
            </div>
          </div>
          <div class="chart-wrap">
            <canvas id="normChart"></canvas>
          </div>
        </div>
      </div>

      <!-- Comparison Table -->
      <div class="card">
        <h2>Method Comparison at Different Counts</h2>
        <p class="muted small" style="margin-bottom: 12px;">
          See how each method scores the same count value. Scores closer to 1.0 are better (green), 
          scores closer to 0.0 are worse (red).
        </p>
        <div style="overflow-x: auto;">
          <table class="comparison-table" id="comparisonTable">
            <!-- Populated by JavaScript -->
          </table>
        </div>
      </div>

      <!-- When to Use Each Method -->
      <div class="card">
        <h2>When to Use Each Method</h2>
        <div class="use-cases" id="useCases">
          <!-- Populated by JavaScript -->
        </div>
      </div>

      <!-- Method Deep Dives -->
      <div class="card" id="methodDeepDive">
        <h2>Method Details</h2>
        <div id="deepDiveContent">
          <!-- Populated by JavaScript -->
        </div>
      </div>
    </div>
  </div>

<script>
(function() {
  // Use shared normalization methods from scorecard-config.js
  const normMethods = window.ScorecardConfig.normMethods;

  // Method colors for charts (same as index.html)
  const methodColors = {
    exponential: { border: "#6ee7b7", bg: "rgba(110,231,183,0.1)" },
    linear: { border: "#fb7185", bg: "rgba(251,113,133,0.1)" },
    inverse: { border: "#93c5fd", bg: "rgba(147,197,253,0.1)" },
    logarithmic: { border: "#fde68a", bg: "rgba(253,230,138,0.1)" },
    sigmoid: { border: "#c4b5fd", bg: "rgba(196,181,253,0.1)" },
    bucket: { border: "#fdba74", bg: "rgba(253,186,116,0.1)" }
  };

  // Method metadata for UI
  const methodMeta = {
    exponential: {
      description: "Each additional count multiplies the score by a decay factor (e.g., 0.85). This creates a smooth curve where the first few counts hurt most, with diminishing impact as counts increase.",
      whenToUse: "Use when you want diminishing returns—the first issue should hurt more than going from 50 to 51.",
      pros: [
        "Smooth, predictable curve",
        "Never reaches exactly zero",
        "Easy to explain: 'each issue costs X%'",
        "Natural diminishing returns"
      ],
      cons: [
        "Can be too forgiving at high counts",
        "Score never truly zeros out"
      ],
      paramDescriptions: {
        decay: "The multiplier applied for each count. Lower values = harsher penalties."
      }
    },
    linear: {
      description: "Score decreases linearly from 1.0 to 0.0 as count approaches a threshold. Once the threshold is reached, score stays at 0.",
      whenToUse: "Use when you want a clear, hard limit. 'More than X issues = zero points.'",
      pros: [
        "Simple and intuitive",
        "Clear threshold creates urgency",
        "Easy to explain to teams"
      ],
      cons: [
        "Discontinuity at threshold can feel arbitrary",
        "No incentive to improve beyond threshold",
        "Equal impact per issue may not reflect reality"
      ],
      paramDescriptions: {
        threshold: "The count at which score reaches zero."
      }
    },
    inverse: {
      description: "Score = 1 / (1 + k × count). Creates a hyperbolic decay that drops quickly at first then levels off. The first issue has the biggest impact.",
      whenToUse: "Use when the first few issues are critical but many issues suggest a systemic problem that's already 'bad enough.'",
      pros: [
        "First issue has maximum impact",
        "Asymptotic approach to zero",
        "Mathematically elegant"
      ],
      cons: [
        "Can be hard to tune the k parameter",
        "May be too forgiving at moderate counts"
      ],
      paramDescriptions: {
        k: "Steepness of decay. Higher k = faster drop."
      }
    },
    logarithmic: {
      description: "Uses logarithmic scaling to compress high counts. Score reaches zero at 'max expected' count. Good for metrics with high variance.",
      whenToUse: "Use when you expect wide variation in counts and want to compress the range. Good for metrics that can span 1 to 1000+.",
      pros: [
        "Handles wide range of values",
        "Early issues hurt more",
        "Clear endpoint at max expected"
      ],
      cons: [
        "Requires knowing 'max expected' value",
        "May not penalize early issues enough"
      ],
      paramDescriptions: {
        maxExpected: "The count at which score reaches zero."
      }
    },
    sigmoid: {
      description: "S-shaped curve centered on a midpoint where score = 0.5. Provides a gradual transition from 'good' to 'bad' with a clear inflection point.",
      whenToUse: "Use when there's a natural 'acceptable' threshold and you want smooth transitions on both sides.",
      pros: [
        "Clear midpoint for 'acceptable' level",
        "Smooth transitions avoid gaming",
        "Starts and ends gradually"
      ],
      cons: [
        "Two parameters to tune",
        "Low counts may score below 1.0",
        "Can be harder to explain"
      ],
      paramDescriptions: {
        midpoint: "The count where score equals 0.5.",
        steepness: "How sharply the curve transitions. Higher = sharper."
      }
    },
    bucket: {
      description: "Step function with predefined thresholds. Score jumps to specific values at each threshold. Provides clear 'tiers' of performance.",
      whenToUse: "Use when you want explicit tiers (A/B/C/D/F style) or when specific count ranges have defined business meaning.",
      pros: [
        "Very explicit and clear",
        "Easy to communicate tiers",
        "Maps to traditional grading",
        "Flexible tier definitions"
      ],
      cons: [
        "Discontinuities can feel unfair",
        "No credit for partial improvement within tier",
        "Requires thoughtful bucket design"
      ],
      paramDescriptions: {
        buckets: "Array of [threshold, score] pairs defining each tier."
      }
    }
  };

  // Current state
  let currentMethod = "exponential";
  let params = {
    exponential: { decay: 0.85 },
    linear: { threshold: 10 },
    inverse: { k: 1.0 },
    logarithmic: { maxExpected: 20 },
    sigmoid: { midpoint: 5, steepness: 1.0 },
    bucket: { buckets: [[0, 1.0], [1, 0.8], [3, 0.5], [6, 0.2], [11, 0.0]] }
  };

  let normChart = null;

  // ---------- URL State Management ----------
  const validMethods = Object.keys(normMethods);

  function getStateFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const state = {};

    // Get method from URL
    const method = urlParams.get("method");
    if (method && validMethods.includes(method)) {
      state.method = method;
    }

    // Get parameters based on method
    if (state.method === "exponential" || urlParams.has("decay")) {
      const decay = parseFloat(urlParams.get("decay"));
      if (!isNaN(decay) && decay >= 0.1 && decay <= 0.99) {
        state.decay = decay;
      }
    }
    if (state.method === "linear" || urlParams.has("threshold")) {
      const threshold = parseInt(urlParams.get("threshold"), 10);
      if (!isNaN(threshold) && threshold >= 1) {
        state.threshold = threshold;
      }
    }
    if (state.method === "inverse" || urlParams.has("k")) {
      const k = parseFloat(urlParams.get("k"));
      if (!isNaN(k) && k >= 0.1) {
        state.k = k;
      }
    }
    if (state.method === "logarithmic" || urlParams.has("maxExpected")) {
      const maxExpected = parseInt(urlParams.get("maxExpected"), 10);
      if (!isNaN(maxExpected) && maxExpected >= 1) {
        state.maxExpected = maxExpected;
      }
    }
    if (state.method === "sigmoid" || urlParams.has("midpoint") || urlParams.has("steepness")) {
      const midpoint = parseInt(urlParams.get("midpoint"), 10);
      const steepness = parseFloat(urlParams.get("steepness"));
      if (!isNaN(midpoint) && midpoint >= 1) {
        state.midpoint = midpoint;
      }
      if (!isNaN(steepness) && steepness >= 0.1) {
        state.steepness = steepness;
      }
    }

    // Get test count if provided
    const count = parseInt(urlParams.get("count"), 10);
    if (!isNaN(count) && count >= 0) {
      state.count = count;
    }

    return state;
  }

  function updateURL() {
    const urlParams = new URLSearchParams();

    // Always include method
    urlParams.set("method", currentMethod);

    // Include relevant parameters for the current method
    const p = params[currentMethod];
    if (currentMethod === "exponential") {
      urlParams.set("decay", p.decay);
    } else if (currentMethod === "linear") {
      urlParams.set("threshold", p.threshold);
    } else if (currentMethod === "inverse") {
      urlParams.set("k", p.k);
    } else if (currentMethod === "logarithmic") {
      urlParams.set("maxExpected", p.maxExpected);
    } else if (currentMethod === "sigmoid") {
      urlParams.set("midpoint", p.midpoint);
      urlParams.set("steepness", p.steepness);
    }
    // bucket params are complex, skip for now

    // Update URL without page reload
    const newURL = `${window.location.pathname}?${urlParams.toString()}`;
    window.history.replaceState({}, "", newURL);
  }

  function applyURLState() {
    const state = getStateFromURL();

    // Apply method
    if (state.method) {
      currentMethod = state.method;
    }

    // Apply parameters
    if (state.decay !== undefined) params.exponential.decay = state.decay;
    if (state.threshold !== undefined) params.linear.threshold = state.threshold;
    if (state.k !== undefined) params.inverse.k = state.k;
    if (state.maxExpected !== undefined) params.logarithmic.maxExpected = state.maxExpected;
    if (state.midpoint !== undefined) params.sigmoid.midpoint = state.midpoint;
    if (state.steepness !== undefined) params.sigmoid.steepness = state.steepness;

    // Apply test count
    if (state.count !== undefined) {
      const countInput = document.getElementById("testCount");
      if (countInput) countInput.value = state.count;
    }
  }

  // Utility functions
  const fmt = (n, d = 2) => n.toFixed(d);

  function getScoreClass(score) {
    if (score >= 0.7) return "score-good";
    if (score >= 0.4) return "score-warn";
    return "score-bad";
  }

  // Initialize method tabs
  function initMethodTabs() {
    const container = document.getElementById("methodTabs");
    container.innerHTML = Object.entries(normMethods).map(([key, method]) => `
      <button class="method-tab ${key === currentMethod ? 'active' : ''}" data-method="${key}">
        <span class="color-dot" style="background: ${methodColors[key].border};"></span>
        ${method.name}
      </button>
    `).join("");

    container.querySelectorAll(".method-tab").forEach(tab => {
      tab.addEventListener("click", () => {
        currentMethod = tab.dataset.method;
        updateAll();
      });
    });
  }

  // Update method info panel
  function updateMethodInfo() {
    const method = normMethods[currentMethod];
    const meta = methodMeta[currentMethod];
    const currentParams = params[currentMethod];

    document.getElementById("methodInfo").innerHTML = `
      <h4>${method.name}</h4>
      <p>${meta.description}</p>
      <div class="formula-box">${method.formula(currentParams)}</div>
      <div class="examples-box">Example: ${method.examples(currentParams)}</div>
      <div class="pros-cons">
        <div class="pros">
          <h5>Pros</h5>
          <ul>${meta.pros.map(p => `<li>${p}</li>`).join("")}</ul>
        </div>
        <div class="cons">
          <h5>Cons</h5>
          <ul>${meta.cons.map(c => `<li>${c}</li>`).join("")}</ul>
        </div>
      </div>
    `;
  }

  // Update parameters panel
  function updateParamsPanel() {
    const container = document.getElementById("paramsPanel");
    const meta = methodMeta[currentMethod];
    const currentParams = params[currentMethod];
    let html = "<h4>Parameters</h4>";

    if (currentMethod === "exponential") {
      html += `
        <div class="param-row">
          <span class="param-label">Decay rate:</span>
          <input type="number" id="paramDecay" step="0.05" min="0.1" max="0.99" value="${currentParams.decay}" />
        </div>
        <div class="param-desc">${meta.paramDescriptions.decay}</div>
      `;
    } else if (currentMethod === "linear") {
      html += `
        <div class="param-row">
          <span class="param-label">Threshold:</span>
          <input type="number" id="paramThreshold" step="1" min="1" value="${currentParams.threshold}" />
        </div>
        <div class="param-desc">${meta.paramDescriptions.threshold}</div>
      `;
    } else if (currentMethod === "inverse") {
      html += `
        <div class="param-row">
          <span class="param-label">Steepness (k):</span>
          <input type="number" id="paramK" step="0.1" min="0.1" value="${currentParams.k}" />
        </div>
        <div class="param-desc">${meta.paramDescriptions.k}</div>
      `;
    } else if (currentMethod === "logarithmic") {
      html += `
        <div class="param-row">
          <span class="param-label">Max expected:</span>
          <input type="number" id="paramMax" step="1" min="1" value="${currentParams.maxExpected}" />
        </div>
        <div class="param-desc">${meta.paramDescriptions.maxExpected}</div>
      `;
    } else if (currentMethod === "sigmoid") {
      html += `
        <div class="param-row">
          <span class="param-label">Midpoint:</span>
          <input type="number" id="paramMidpoint" step="1" min="1" value="${currentParams.midpoint}" />
        </div>
        <div class="param-desc">${meta.paramDescriptions.midpoint}</div>
        <div class="param-row" style="margin-top: 12px;">
          <span class="param-label">Steepness:</span>
          <input type="number" id="paramSteepness" step="0.1" min="0.1" value="${currentParams.steepness}" />
        </div>
        <div class="param-desc">${meta.paramDescriptions.steepness}</div>
      `;
    } else if (currentMethod === "bucket") {
      html += `
        <div class="param-desc">${meta.paramDescriptions.buckets}</div>
        <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 10px;">
          ${currentParams.buckets.map(([t, s]) => `
            <span class="mono" style="background: rgba(255,255,255,.1); padding: 6px 10px; border-radius: 6px;">
              ${t}+ → ${fmt(s)}
            </span>
          `).join("")}
        </div>
      `;
    }

    container.innerHTML = html;
    attachParamListeners();
  }

  // Attach parameter input listeners
  function attachParamListeners() {
    const handleChange = () => {
      updateMethodInfo();
      updateChart();
      updateTestResults();
      updateComparisonTable();
      updateURL();
    };

    if (currentMethod === "exponential") {
      const inp = document.getElementById("paramDecay");
      if (inp) inp.addEventListener("input", () => {
        params.exponential.decay = Math.max(0.1, Math.min(0.99, Number(inp.value) || 0.85));
        handleChange();
      });
    } else if (currentMethod === "linear") {
      const inp = document.getElementById("paramThreshold");
      if (inp) inp.addEventListener("input", () => {
        params.linear.threshold = Math.max(1, Number(inp.value) || 10);
        handleChange();
      });
    } else if (currentMethod === "inverse") {
      const inp = document.getElementById("paramK");
      if (inp) inp.addEventListener("input", () => {
        params.inverse.k = Math.max(0.1, Number(inp.value) || 1);
        handleChange();
      });
    } else if (currentMethod === "logarithmic") {
      const inp = document.getElementById("paramMax");
      if (inp) inp.addEventListener("input", () => {
        params.logarithmic.maxExpected = Math.max(1, Number(inp.value) || 20);
        handleChange();
      });
    } else if (currentMethod === "sigmoid") {
      const mid = document.getElementById("paramMidpoint");
      const steep = document.getElementById("paramSteepness");
      if (mid) mid.addEventListener("input", () => {
        params.sigmoid.midpoint = Math.max(1, Number(mid.value) || 5);
        handleChange();
      });
      if (steep) steep.addEventListener("input", () => {
        params.sigmoid.steepness = Math.max(0.1, Number(steep.value) || 1);
        handleChange();
      });
    }
  }

  // Update test results
  function updateTestResults() {
    const count = Number(document.getElementById("testCount").value) || 0;
    const container = document.getElementById("testResults");

    container.innerHTML = Object.entries(normMethods).map(([key, method]) => {
      const score = method.calc(count, params[key]);
      const color = methodColors[key].border;
      return `
        <div class="result-card" style="border-left: 3px solid ${color};">
          <div class="label">Score</div>
          <div class="value ${getScoreClass(score)}" style="color: ${color};">${fmt(score, 4)}</div>
          <div class="method-name-small">${method.name}</div>
        </div>
      `;
    }).join("");
  }

  // Update chart
  function updateChart() {
    const showAll = document.getElementById("showAllMethods").checked;
    const labels = Array.from({ length: 31 }, (_, i) => i); // 0 to 30
    const datasets = [];

    if (showAll) {
      Object.entries(normMethods).forEach(([key, method]) => {
        const data = labels.map(count => method.calc(count, params[key]));
        const isSelected = key === currentMethod;
        
        datasets.push({
          label: method.name,
          data: data,
          borderColor: methodColors[key].border,
          backgroundColor: isSelected ? methodColors[key].bg : "transparent",
          borderWidth: isSelected ? 3 : 1.5,
          pointRadius: 0,
          tension: key === "bucket" ? 0 : 0.3,
          stepped: key === "bucket" ? "before" : false,
          fill: isSelected,
          order: isSelected ? 0 : 1
        });
      });
    } else {
      const method = normMethods[currentMethod];
      const data = labels.map(count => method.calc(count, params[currentMethod]));
      
      datasets.push({
        label: method.name,
        data: data,
        borderColor: methodColors[currentMethod].border,
        backgroundColor: methodColors[currentMethod].bg,
        borderWidth: 3,
        pointRadius: 0,
        tension: currentMethod === "bucket" ? 0 : 0.3,
        stepped: currentMethod === "bucket" ? "before" : false,
        fill: true
      });
    }

    if (normChart) {
      normChart.data.labels = labels;
      normChart.data.datasets = datasets;
      normChart.options.plugins.legend.display = showAll;
      normChart.update("none");
    } else {
      normChart = new Chart(document.getElementById("normChart"), {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: "index"
          },
          plugins: {
            legend: {
              display: showAll,
              position: "bottom",
              labels: {
                color: "#a9b4d6",
                font: { size: 11 },
                boxWidth: 12,
                padding: 8
              }
            },
            tooltip: {
              backgroundColor: "rgba(17,25,53,0.95)",
              titleColor: "#e9eefc",
              bodyColor: "#a9b4d6",
              borderColor: "rgba(255,255,255,0.1)",
              borderWidth: 1,
              padding: 10,
              callbacks: {
                title: (items) => `Count: ${items[0].label}`,
                label: (item) => `${item.dataset.label}: ${item.parsed.y.toFixed(4)}`
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Count",
                color: "#a9b4d6",
                font: { size: 11 }
              },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            },
            y: {
              min: 0,
              max: 1,
              title: {
                display: true,
                text: "Normalized Score (0-1)",
                color: "#a9b4d6",
                font: { size: 11 }
              },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            }
          }
        }
      });
    }
  }

  // Update comparison table
  function updateComparisonTable() {
    const testCounts = [0, 1, 3, 5, 10, 15, 20, 25, 30];
    const container = document.getElementById("comparisonTable");

    let html = `
      <thead>
        <tr>
          <th>Method</th>
          ${testCounts.map(c => `<th class="right">${c}</th>`).join("")}
        </tr>
      </thead>
      <tbody>
    `;

    Object.entries(normMethods).forEach(([key, method]) => {
      html += `
        <tr>
          <td>
            <span class="method-name">
              <span class="method-dot" style="background: ${methodColors[key].border};"></span>
              ${method.name}
            </span>
          </td>
          ${testCounts.map(count => {
            const score = method.calc(count, params[key]);
            return `<td class="mono right"><span class="score-badge ${getScoreClass(score)}">${fmt(score, 2)}</span></td>`;
          }).join("")}
        </tr>
      `;
    });

    html += "</tbody>";
    container.innerHTML = html;
  }

  // Update use cases section
  function updateUseCases() {
    const container = document.getElementById("useCases");

    container.innerHTML = Object.entries(methodMeta).map(([key, meta]) => `
      <div class="use-case" style="border-left: 3px solid ${methodColors[key].border};">
        <h4>${normMethods[key].name}</h4>
        <p>${meta.whenToUse}</p>
      </div>
    `).join("");
  }

  // Update deep dive content
  function updateDeepDive() {
    const container = document.getElementById("deepDiveContent");
    
    container.innerHTML = Object.entries(normMethods).map(([key, method]) => {
      const meta = methodMeta[key];
      const currentParams = params[key];
      
      return `
        <div style="margin-bottom: 24px; padding-bottom: 24px; border-bottom: 1px solid var(--border);">
          <h3 style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
            <span class="method-dot" style="background: ${methodColors[key].border}; width: 12px; height: 12px; border-radius: 50%;"></span>
            ${method.name}
          </h3>
          <p class="muted" style="margin-bottom: 12px;">${meta.description}</p>
          <div class="formula-box">${method.formula(currentParams)}</div>
          <p class="small muted" style="margin-top: 8px;">Example values: ${method.examples(currentParams)}</p>
        </div>
      `;
    }).join("");
  }

  // Update tab active states
  function updateTabStates() {
    document.querySelectorAll(".method-tab").forEach(tab => {
      tab.classList.toggle("active", tab.dataset.method === currentMethod);
    });
  }

  // Update all components
  function updateAll() {
    updateTabStates();
    updateMethodInfo();
    updateParamsPanel();
    updateChart();
    updateTestResults();
    updateComparisonTable();
    updateDeepDive();
    updateURL();
  }

  // Initialize
  function init() {
    // Apply URL state before initializing UI
    applyURLState();

    initMethodTabs();
    updateMethodInfo();
    updateParamsPanel();
    updateChart();
    updateTestResults();
    updateComparisonTable();
    updateUseCases();
    updateDeepDive();

    // Set initial URL (in case we loaded with defaults)
    updateURL();

    // Event listeners
    document.getElementById("testCount").addEventListener("input", updateTestResults);
    document.getElementById("showAllMethods").addEventListener("change", updateChart);

    // Handle browser back/forward navigation
    window.addEventListener("popstate", () => {
      applyURLState();
      updateAll();
    });
  }

  // Run on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
  } else {
    init();
  }
})();
</script>
</body>
</html>
