<!doctype html>
<html lang="en" style="scroll-behavior: smooth;">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />
  <title>Scorecard Playground</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="cache-version.js?v=1.0.4"></script>
  <script src="team-navigation.js?v=1.0.4"></script>
  <script src="scorecard-config.js?v=1.0.4"></script>
  <script src="scorecard-compute.js?v=1.0.4"></script>
  <script src="mock-data.js?v=1.0.4"></script>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #111935;
      --panel2: #0f1730;
      --text: #e9eefc;
      --muted: #a9b4d6;
      --border: rgba(255,255,255,.10);
      --good: #6ee7b7;
      --warn: #fde68a;
      --bad: #fb7185;
      --accent: #93c5fd;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 10% 10%, rgba(147,197,253,.14), transparent),
                  radial-gradient(1000px 600px at 90% 20%, rgba(110,231,183,.10), transparent),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 40px 20px;
    }

    .page-layout {
      display: flex;
      gap: 0;
      min-height: calc(100vh - 80px);
      max-width: 1400px;
      margin: 0 auto;
    }

    .sidebar {
      position: sticky;
      top: 40px;
      height: calc(100vh - 80px);
      overflow-y: auto;
      width: 220px;
      flex-shrink: 0;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border-right: 1px solid var(--border);
      border-radius: 12px 0 0 12px;
      padding: 24px 16px;
    }

    .sidebar-main-title {
      font-size: 16px;
      font-weight: 700;
      margin: 0 0 24px;
      color: var(--text);
      letter-spacing: .2px;
      text-align: center;
    }

    .sidebar-title {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .8px;
      color: var(--muted);
      margin: 0 0 14px;
    }

    /* Score summary */
    .score-summary {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      margin-bottom: 20px;
    }

    .grade-badge {
      font-size: 28px;
      font-weight: 800;
      width: 52px;
      height: 52px;
      border-radius: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      letter-spacing: -1px;
    }

    .grade-A { background: rgba(110,231,183,.18); color: #6ee7b7; border: 1px solid rgba(110,231,183,.3); }
    .grade-B { background: rgba(147,197,253,.18); color: #93c5fd; border: 1px solid rgba(147,197,253,.3); }
    .grade-C { background: rgba(253,230,138,.18); color: #fde68a; border: 1px solid rgba(253,230,138,.3); }
    .grade-D { background: rgba(251,113,133,.18); color: #fb7185; border: 1px solid rgba(251,113,133,.3); }
    .grade-F { background: rgba(239,68,68,.18); color: #ef4444; border: 1px solid rgba(239,68,68,.3); }

    .score-total {
      text-align: center;
      font-family: var(--mono);
    }

    .score-earned {
      font-size: 22px;
      font-weight: 700;
      color: var(--text);
    }

    .score-max {
      font-size: 16px;
      color: var(--muted);
      font-weight: 400;
    }

    .score-pct {
      font-size: 13px;
      color: var(--muted);
      font-weight: 500;
    }

    /* Category rows */
    .category-row {
      display: block;
      text-decoration: none;
      padding: 12px;
      margin: 0 -12px;
      border-radius: 10px;
      transition: background .15s;
    }

    .category-row:hover {
      background: rgba(255,255,255,.06);
    }

    .category-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 4px;
    }

    .category-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .category-dot.slo { background: #93c5fd; }
    .category-dot.vuln { background: #fb7185; }
    .category-dot.bugs { background: #fde68a; }

    .category-name {
      flex: 1;
      font-size: 13px;
      font-weight: 600;
      color: var(--text);
    }

    .category-pct {
      font-family: var(--mono);
      font-size: 12px;
      font-weight: 600;
    }

    .category-pct.good { color: var(--good); }
    .category-pct.warn { color: var(--warn); }
    .category-pct.bad { color: var(--bad); }

    .category-score {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--muted);
      margin-bottom: 6px;
      padding-left: 16px;
    }

    .category-bar {
      height: 6px;
      border-radius: 3px;
      background: rgba(255,255,255,.08);
      overflow: hidden;
      margin-left: 16px;
    }

    .category-bar > div {
      height: 100%;
      border-radius: 3px;
      transition: width .3s ease;
    }

    .category-bar.good > div { background: var(--good); }
    .category-bar.warn > div { background: var(--warn); }
    .category-bar.bad > div { background: var(--bad); }

    /* Sidebar action links */
    .dashboard-link,
    .data-editor-link {
      display: block;
      text-align: center;
      padding: 10px 14px;
      margin-top: 12px;
      background: rgba(147,197,253,.12);
      border: 1px solid rgba(147,197,253,.25);
      border-radius: 8px;
      color: var(--accent);
      font-size: 13px;
      font-weight: 600;
      text-decoration: none;
      transition: background .15s, border-color .15s;
    }

    .dashboard-link:hover,
    .data-editor-link:hover {
      background: rgba(147,197,253,.20);
      border-color: rgba(147,197,253,.40);
    }

    /* Priority work list */
    .priority-work {
      margin-top: 24px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
    }

    .priority-items {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .priority-item {
      display: block;
      text-decoration: none;
      padding: 10px;
      margin: 0 -10px;
      border-radius: 8px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.08);
      transition: background .15s, border-color .15s;
      position: relative;
    }

    .priority-item:hover {
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.12);
    }
    
    .priority-item.flip-animating {
      transition: transform 0.5s cubic-bezier(0.22, 1, 0.36, 1), 
                  background .15s, border-color .15s;
      z-index: 10;
    }
    
    .priority-item.flip-animating::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 8px;
      background: linear-gradient(90deg, transparent, rgba(147, 197, 253, 0.1), transparent);
      animation: shimmer 0.5s ease-out;
      pointer-events: none;
    }
    
    @keyframes shimmer {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .priority-item.entering {
      animation: fadeInSlide 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    }
    
    .priority-item.exiting {
      animation: fadeOutSlide 0.3s cubic-bezier(0.22, 1, 0.36, 1) forwards;
    }
    
    @keyframes fadeInSlide {
      from {
        opacity: 0;
        transform: translateX(-20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateX(0) scale(1);
      }
    }
    
    @keyframes fadeOutSlide {
      from {
        opacity: 1;
        transform: translateX(0) scale(1);
      }
      to {
        opacity: 0;
        transform: translateX(20px) scale(0.95);
      }
    }

    .priority-item-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .priority-item-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .priority-item-category {
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .6px;
      color: var(--muted);
    }

    .priority-item-opportunity {
      margin-left: auto;
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 700;
      color: var(--good);
    }

    .priority-item-name {
      font-size: 12px;
      color: var(--text);
      line-height: 1.4;
      padding-left: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .priority-empty {
      font-size: 11px;
      color: var(--muted);
      text-align: center;
      padding: 16px 0;
    }

    .wrap {
      flex: 1;
      min-width: 0;
      max-width: 1100px;
      padding: 24px 32px 60px;
    }

    @media (max-width: 900px) {
      .page-layout {
        flex-direction: column;
      }
      .sidebar {
        position: static;
        width: 100%;
        height: auto;
        border-right: none;
        border-bottom: 1px solid var(--border);
        padding: 16px;
      }
      .wrap {
        padding: 24px 18px 60px;
      }
    }

    header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 18px;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: .2px;
    }

    .sub {
      color: var(--muted);
      font-size: 13px;
      max-width: 66ch;
      line-height: 1.4;
      margin-top: 6px;
    }

    .grid {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.30);
    }

    .card h2 {
      margin: 0 0 10px;
      font-size: 14px;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: .2px;
      text-transform: uppercase;
    }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    label {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      gap: 8px;
      align-items: center;
    }

    input[type="text"], input[type="number"], select {
      background: rgba(0,0,0,.22);
      border: 1px solid var(--border);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      outline: none;
    }

    input[type="number"] { width: 88px; }
    input[type="text"] { width: 160px; }
    select { padding: 8px 10px; }

    input[type="range"] { width: 220px; }

    .btn {
      background: rgba(147,197,253,.16);
      border: 1px solid rgba(147,197,253,.35);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      cursor: pointer;
      font-weight: 600;
      letter-spacing: .2px;
      transition: transform .05s ease;
    }
    .btn:active { transform: translateY(1px); }

    .btn.secondary {
      background: rgba(255,255,255,.06);
      border-color: var(--border);
      color: var(--text);
    }

    .btn.danger {
      background: rgba(251,113,133,.14);
      border-color: rgba(251,113,133,.35);
    }

    table {
      width: 100%;
      border-collapse: collapse;
      overflow: hidden;
      border-radius: 12px;
      border: 1px solid var(--border);
    }
    thead th {
      font-size: 12px;
      color: var(--muted);
      text-align: left;
      padding: 10px 8px;
      background: rgba(0,0,0,.18);
      border-bottom: 1px solid var(--border);
    }
    tbody td {
      padding: 10px 8px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      vertical-align: middle;
    }
    tbody tr:last-child td { border-bottom: none; }
    tbody input[type="text"] { width: 140px; }
    tbody input[type="number"] { width: 80px; }
    tbody select { width: 86px; }


    .aggregate-viz {
      margin-top: 14px;
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
    }
    .agg-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .agg-header .title {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      font-weight: 700;
      letter-spacing: .3px;
    }
    .formula-inline {
      font-size: 11px;
      color: var(--accent);
    }
    .agg-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .agg-table th {
      text-align: left;
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .3px;
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      font-weight: 600;
    }
    .agg-table th.right {
      text-align: right;
    }
    .agg-table td {
      padding: 10px;
      border-bottom: 1px solid rgba(255,255,255,.06);
    }
    .agg-table td.mono {
      font-family: var(--mono);
    }
    .agg-table td.right {
      text-align: right;
    }
    .agg-table tr:last-child td {
      border-bottom: none;
    }
    .agg-table tfoot td {
      padding-top: 12px;
      border-top: 1px solid var(--border);
      font-weight: 600;
    }
    .muted { color: var(--muted); }
    .mono { font-family: var(--mono); }

    .section-title {
      font-size: 18px;
      font-weight: 700;
      color: var(--text);
      margin: 0 0 14px 0;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border);
    }

    .config-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .config-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: .2px;
    }

    .method-params {
      margin-top: 14px;
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }
    .method-params .param-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    .method-params .param-row:last-child {
      margin-bottom: 0;
    }
    .method-params .param-label {
      min-width: 120px;
      font-size: 13px;
      color: var(--muted);
    }
    .method-params .formula-display {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
      font-family: var(--mono);
      font-size: 12px;
      color: var(--accent);
    }
    .method-params .example-display {
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
    }

    .chart-container {
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }

    .intro-box {
      background: linear-gradient(135deg, rgba(147,197,253,.08), rgba(110,231,183,.05));
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px 22px;
      margin-bottom: 14px;
      line-height: 1.55;
    }
    .intro-box h3 {
      margin: 0 0 12px;
      font-size: 15px;
      font-weight: 700;
      color: var(--text);
    }
    .intro-box h4 {
      margin: 16px 0 10px;
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .2px;
    }
    .intro-box p {
      margin: 0 0 12px;
      font-size: 13px;
      color: var(--text);
    }
    .intro-box ul {
      margin: 0;
      padding-left: 20px;
      font-size: 13px;
      color: var(--text);
    }
    .intro-box li {
      margin-bottom: 10px;
    }
    .intro-box li:last-child {
      margin-bottom: 0;
    }
    .intro-box strong {
      color: var(--accent);
    }
    .intro-box em {
      color: var(--good);
      font-style: normal;
    }

    .pill {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      border: 1px solid var(--border);
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(0,0,0,.18);
      font-size: 13px;
      color: var(--muted);
    }

    .kpi {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .kpi .box {
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 12px;
    }
    .kpi .box .label {
      color: var(--muted);
      font-size: 12px;
      margin-bottom: 6px;
    }
    .kpi .box .value {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: .2px;
    }

    .bar {
      height: 14px;
      border-radius: 999px;
      background: rgba(255,255,255,.10);
      overflow: hidden;
      border: 1px solid var(--border);
    }
    .bar > div {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(110,231,183,.9), rgba(147,197,253,.9));
      transition: width .15s ease;
    }

    .note {
      margin-top: 10px;
      font-size: 13px;
      color: var(--muted);
      line-height: 1.45;
    }

    .formula {
      margin-top: 10px;
      background: rgba(0,0,0,.22);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 10px 12px;
      font-family: var(--mono);
      font-size: 12px;
      color: #dbeafe;
      line-height: 1.5;
      overflow: auto;
      white-space: pre;
    }

    .small { font-size: 12px; color: var(--muted); }

    /* Welcome Hero */
    .welcome-hero {
      background: linear-gradient(135deg, rgba(147,197,253,.12) 0%, rgba(110,231,183,.08) 50%, rgba(196,181,253,.10) 100%);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 32px 36px;
      margin-bottom: 28px;
      position: relative;
      overflow: hidden;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 32px;
      align-items: center;
    }

    .welcome-hero-left {
      display: flex;
      flex-direction: column;
    }

    .welcome-hero-right {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .welcome-hero::before {
      content: "";
      position: absolute;
      top: -50%;
      right: -20%;
      width: 400px;
      height: 400px;
      background: radial-gradient(circle, rgba(147,197,253,.15) 0%, transparent 70%);
      pointer-events: none;
    }

    .welcome-badge {
      display: inline-block;
      background: rgba(147,197,253,.18);
      border: 1px solid rgba(147,197,253,.35);
      color: var(--accent);
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 6px 12px;
      border-radius: 999px;
      margin-bottom: 16px;
    }

    .welcome-title {
      font-size: 28px;
      font-weight: 800;
      color: var(--text);
      margin: 0 0 12px;
      letter-spacing: -0.5px;
      line-height: 1.2;
    }

    .welcome-desc {
      font-size: 15px;
      color: var(--muted);
      line-height: 1.6;
      max-width: 600px;
      margin: 0 0 24px;
    }

    .welcome-features {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 14px;
      margin-bottom: 20px;
    }

    .welcome-feature {
      display: flex;
      gap: 12px;
      align-items: flex-start;
      background: rgba(0,0,0,.18);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px 16px;
      transition: transform .15s ease, border-color .15s ease;
    }

    .welcome-feature:hover {
      transform: translateY(-2px);
      border-color: rgba(147,197,253,.3);
    }

    .feature-icon {
      font-size: 20px;
      flex-shrink: 0;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255,255,255,.06);
      border-radius: 10px;
    }

    .feature-text {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .feature-text strong {
      font-size: 13px;
      font-weight: 700;
      color: var(--text);
    }

    .feature-text span {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }

    .welcome-hint {
      font-size: 13px;
      color: var(--muted);
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .hint-arrow {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      background: rgba(110,231,183,.15);
      border-radius: 50%;
      color: var(--good);
      font-size: 14px;
      animation: bounce 2s infinite;
    }

    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(4px); }
      60% { transform: translateY(2px); }
    }

    .welcome-video {
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid var(--border);
      box-shadow: 0 10px 40px rgba(0,0,0,.4);
      position: relative;
      padding-bottom: 56.25%; /* 16:9 aspect ratio for YouTube */
      height: 0;
      width: 100%;
    }

    .welcome-video iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 12px;
    }

    @media (max-width: 900px) {
      .welcome-hero {
        grid-template-columns: 1fr;
      }
      .welcome-hero-right {
        order: -1;
      }
    }

    @media (max-width: 600px) {
      .welcome-hero {
        padding: 24px 20px;
      }
      .welcome-title {
        font-size: 22px;
      }
      .welcome-features {
        grid-template-columns: 1fr;
      }
    }

    .top-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 16px;
      padding: 20px 40px;
      background: rgba(255,255,255,.03);
      border-bottom: 1px solid var(--border);
    }

    .top-header-left {
      display: flex;
      align-items: center;
      gap: 20px;
      flex-wrap: wrap;
    }

    .top-header-title {
      font-size: 20px;
      font-weight: 700;
      margin: 0;
      letter-spacing: -0.3px;
    }

    .team-selector-wrapper {
      margin-bottom: 20px;
    }

    .team-selector-wrapper select {
      font-size: 13px;
      padding: 10px 12px;
      background: rgba(255,255,255,.08);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      cursor: pointer;
      width: 100%;
    }

    .team-selector-wrapper select:hover {
      background: rgba(255,255,255,.12);
    }

    .nav-links {
      display: flex;
      gap: 12px;
    }

    .nav-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 10px 18px;
      background: rgba(255,255,255,.08);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
      font-weight: 600;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .nav-btn:hover {
      background: rgba(255,255,255,.14);
      border-color: rgba(255,255,255,.20);
      transform: translateY(-1px);
    }

    @media (max-width: 900px) {
      .top-header {
        padding: 16px 20px;
      }
      .top-header-left {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="page-layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <h1 class="sidebar-main-title">Team Scorecard</h1>

      <!-- Team Selector -->
      <div class="team-selector-wrapper">
        <select id="teamSelector">
          <option value="">Loading teams...</option>
        </select>
      </div>

      <!-- Overall Score Summary -->
      <div class="score-summary">
        <div class="grade-badge grade-B" id="gradeBadge">B</div>
        <div class="score-total">
          <span class="score-earned" id="sidebarTotalScore">‚Äî</span>
          <span class="score-max"> / <span id="sidebarTotalMax">60</span></span>
        </div>
      </div>

      <!-- Category Breakdown -->
      <a href="#section-vulns" class="category-row" id="categoryVuln">
        <div class="category-header">
          <span class="category-dot vuln"></span>
          <span class="category-name">Vulns</span>
          <span class="category-pct" id="sidebarVulnPct">‚Äî%</span>
        </div>
        <div class="category-score" id="sidebarVulnScore">‚Äî / ‚Äî</div>
        <div class="category-bar" id="sidebarVulnBar"><div></div></div>
      </a>

      <a href="#section-slos" class="category-row" id="categorySlo">
        <div class="category-header">
          <span class="category-dot slo"></span>
          <span class="category-name">SLOs</span>
          <span class="category-pct" id="sidebarSloPct">‚Äî%</span>
        </div>
        <div class="category-score" id="sidebarSloScore">‚Äî / ‚Äî</div>
        <div class="category-bar" id="sidebarSloBar"><div></div></div>
      </a>

      <a href="#section-bugs" class="category-row" id="categoryBugs">
        <div class="category-header">
          <span class="category-dot bugs"></span>
          <span class="category-name">Bugs</span>
          <span class="category-pct" id="sidebarBugsPct">‚Äî%</span>
        </div>
        <div class="category-score" id="sidebarBugsScore">‚Äî / ‚Äî</div>
        <div class="category-bar" id="sidebarBugsBar"><div></div></div>
      </a>

      <a href="#section-postmortems" class="category-row" id="categoryPm">
        <div class="category-header">
          <span class="category-dot" style="background: #c4b5fd;"></span>
          <span class="category-name">Postmortems</span>
          <span class="category-pct" id="sidebarPmPct">‚Äî%</span>
        </div>
        <div class="category-score" id="sidebarPmScore">‚Äî / ‚Äî</div>
        <div class="category-bar" id="sidebarPmBar"><div></div></div>
      </a>

      <!-- Dashboard Link -->
      <a href="dashboard.html" class="dashboard-link" id="dashboardLink">
        üìä Scorecard Dashboard
      </a>

      <!-- Normalization Explorer Link -->
      <a href="normalization-explorer.html" class="dashboard-link" id="normExplorerLink">
        üìà Normalization Explorer
      </a>

      <!-- Top Opportunities List -->
      <div class="priority-work">
        <h3 class="sidebar-title">Top 5 Opportunities</h3>
        <div id="priorityItems" class="priority-items">
          <!-- Dynamically populated -->
        </div>
        <a href="data-editor.html" class="data-editor-link" id="dataEditorLink">
          ‚úèÔ∏è Data Editor
        </a>
      </div>
    </aside>

    <!-- Main content -->
    <div class="wrap">
      <!-- Welcome Introduction -->
      <div class="welcome-hero">
        <div class="welcome-hero-left">
          <h1 class="welcome-title">Design your company's scorecards</h1>
          <p class="welcome-desc">
            This configuration playground lets you design a single scoring model that applies to all teams across your organization. 
            Select any team from the sidebar to simulate how your configuration affects their scores in real-time.
            All changes to weights, thresholds, and normalization methods apply globally to every team.
          </p>
          
          <div class="welcome-features">
            <div class="welcome-feature">
              <span class="feature-icon">‚ö°</span>
              <div class="feature-text">
                <strong>Live calculations</strong>
                <span>See scores update instantly as you tweak inputs</span>
              </div>
            </div>
            <div class="welcome-feature">
              <span class="feature-icon">üéõÔ∏è</span>
              <div class="feature-text">
                <strong>Global configuration</strong>
                <span>One scoring model applied across all teams</span>
              </div>
            </div>
            <div class="welcome-feature">
              <span class="feature-icon">üìä</span>
              <div class="feature-text">
                <strong>Team simulation</strong>
                <span>Test your config against real team data</span>
              </div>
            </div>
            <div class="welcome-feature">
              <span class="feature-icon">üíæ</span>
              <div class="feature-text">
                <strong>Persistent configuration</strong>
                <span>Changes saved automatically for all teams</span>
              </div>
            </div>
          </div>

          <p class="welcome-hint" style="margin-top: 20px;">
            <span class="hint-arrow">‚Üì</span> Scroll down to explore each scoring category, or use the sidebar to jump to a specific section.
          </p>
        </div>

        <div class="welcome-hero-right">
          <div class="welcome-video">
            <iframe 
              width="560" 
              height="315" 
              src="https://www.youtube.com/embed/605fxputDxM?rel=0&modestbranding=1" 
              title="Scorecard Playground Introduction" 
              frameborder="0" 
              allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
              referrerpolicy="strict-origin-when-cross-origin"
              allowfullscreen>
            </iframe>
          </div>
        </div>
      </div>

      <h2 class="section-title" id="section-slos">SLOs</h2>

    <div class="intro-box">
      <h3>Score design</h3>
      <p>
        A <em>Service Level Objective (SLO)</em> defines a target for how reliably a service should perform‚Äîfor example, 
        "99.9% of requests complete successfully." The <em>error budget</em> is the allowed margin for failure: 
        if your target is 99.9%, you have a 0.1% error budget.
      </p>
      <p>
        <strong>Error budget remaining (EB%)</strong> tells you how much of that budget you've used. 
        100% means you haven't used any budget (perfect reliability). 
        0% means you've exhausted your budget exactly (meeting your target). 
        <strong>Negative EB%</strong> means you've exceeded your error budget‚Äîmore failures than your SLO allows.
      </p>
      
      <h4>Key design decisions</h4>
      <ul>
        <li>
          <strong>Meeting your SLO = full points.</strong>
          Any SLO with EB% >= 0 receives a perfect normalized score of 1.0. 
          There's no additional reward for "overperforming" (e.g., 99.99% vs 99.9%). 
          This reflects the philosophy that meeting your SLO is the goal.
        </li>
        <li>
          <strong>Penalty for negative error budgets.</strong>
          When EB% < 0, a penalty is applied using a normalization function (exponential decay, linear, etc.). 
          The magnitude of the negative EB% determines the penalty‚Äîe.g., -5% gets a small penalty, -40% gets a large penalty.
        </li>
        <li>
          <strong>Weight by tier.</strong>
          SLOs are assigned tiers (p0, p1, p2) reflecting their importance. 
          A p0 (critical) SLO with negative EB% drags the score down more than a p2.
        </li>
        <li>
          <strong>Weighted average.</strong>
          The final score S is a weighted average: S = Œ£(w·µ¢¬∑s·µ¢) / Œ£(w·µ¢), 
          where each SLO contributes proportionally to its weight.
        </li>
      </ul>

      <h4>Recommendation: Exponential decay (Œª = 0.85)</h4>
      <p>
        We recommend <strong>exponential decay</strong> with a decay rate of <strong>0.85</strong> for penalizing negative EB%. 
        This means each percentage point of negative error budget multiplies your score by 0.85.
      </p>
      <p><strong>Why percentage points as the unit?</strong></p>
      <ul style="margin-top: 8px; font-size: 13px;">
        <li>
          <strong>Already normalized:</strong> EB% is inherently a ratio‚Äîit compares your actual error budget 
          consumption to your allowed budget. A -10% EB means you've exceeded your budget by 10% of the total, 
          regardless of whether that's a 99.9% or 99% SLO. This makes the penalty comparable across different SLOs.
        </li>
        <li>
          <strong>Interpretable scale:</strong> One percentage point represents a meaningful operational violation. 
          For a 30-day SLO with a 99.9% target (43.2 minutes allowed downtime), each -1% EB represents roughly 
          25 additional minutes of downtime. This is a concrete, actionable unit.
        </li>
        <li>
          <strong>Balanced sensitivity:</strong> Using the raw magnitude (-10 becomes count=10) provides reasonable 
          granularity. Going to -5% EB is noticeably worse than -3%, but not catastrophically so. 
          Using finer units (e.g., 0.1% increments) would make the penalty curve too harsh; 
          coarser units (e.g., 10% increments) would be too forgiving.
        </li>
      </ul>
      <p class="muted" style="margin-top: 8px;">
        With Œª = 0.85: -1% EB ‚Üí 0.85, -3% EB ‚Üí 0.61, -5% EB ‚Üí 0.44, -10% EB ‚Üí 0.20, -20% EB ‚Üí 0.04
      </p>
      
      <p class="muted" style="margin-bottom: 0;">
        Adjust tier weights, normalization method, and SLO inputs below to see how they affect the final score.
      </p>
    </div>

    <div class="grid">
      <!-- Configuration -->
      <div class="card">
        <h2>Configuration</h2>

        <div class="config-group">
          <div class="config-label">Tier weights</div>
          <div class="row">
            <label>p0 <input id="wP0" type="number" step="0.1" value="2.0" /></label>
            <label>p1 <input id="wP1" type="number" step="0.1" value="1.0" /></label>
            <label>p2 <input id="wP2" type="number" step="0.1" value="0.5" /></label>
          </div>
          </div>

        <div class="config-group" style="margin-top: 14px;">
          <div class="config-label">Score budget</div>
          <div class="row">
            <input id="pointBudget" type="number" min="0" max="100" step="1" value="35" style="width: 80px;" />
            <span class="muted">/100 (global)</span>
          </div>
        </div>

        <div class="config-group" style="margin-top: 14px;">
          <div class="config-label">Normalization method</div>
          <select id="sloMethod" style="width: 100%; max-width: 300px;">
            <option value="exponential">Exponential decay</option>
            <option value="linear">Linear threshold</option>
            <option value="inverse">Inverse (hyperbolic)</option>
            <option value="logarithmic">Logarithmic</option>
            <option value="sigmoid">Sigmoid (S-curve)</option>
            <option value="bucket">Bucket / Step function</option>
          </select>
        </div>

        <div class="method-params" id="sloMethodParams">
          <!-- Dynamically populated based on selected method -->
        </div>

        <div class="chart-container" style="margin-top: 14px;">
          <div class="config-label" style="margin-bottom: 8px;">Normalization curve</div>
          <div style="position: relative; height: 200px;">
            <canvas id="sloChart"></canvas>
          </div>
          <div class="row" style="margin-top: 8px; gap: 8px;">
            <label style="font-size: 12px;">
              <input type="checkbox" id="sloShowAllMethods" /> Show all methods
            </label>
          </div>
        </div>
        </div>

      <!-- SLO Inputs -->
      <div class="card">
        <h2>Inputs</h2>

          <table>
            <thead>
              <tr>
                <th>SLO</th>
                <th>Tier</th>
                <th>EB%</th>
                <th></th>
              </tr>
            </thead>
            <tbody id="sloTbody"></tbody>
          </table>

        <div class="row" style="justify-content: flex-end; margin-top: 12px;">
          <button class="btn" id="addSlo">+ Add SLO</button>
        </div>
      </div>

      <!-- Results + visualization -->
      <div class="card">
        <h2>Results</h2>

        <div class="kpi">
          <div class="box">
            <div class="label">Weighted average <span class="mono">S</span> (0..1)</div>
            <div class="value mono" id="scoreS">0.0000</div>
            <div class="bar" style="margin-top: 10px;"><div id="scoreBar"></div></div>
          </div>
          <div class="box">
            <div class="label">Score (0..<span id="pointsMax">20</span>)</div>
            <div class="value mono" id="points">0.00</div>
            <div class="small muted" id="pointsNote"></div>
          </div>
        </div>

        <div class="aggregate-viz">
          <div class="agg-header">
            <span class="title">Weighted aggregate</span>
            <span class="formula-inline mono">S = Œ£(w·µ¢¬∑s·µ¢) / Œ£(w·µ¢)</span>
          </div>
          <table class="agg-table" id="aggTable">
            <thead></thead>
            <tbody></tbody>
            <tfoot></tfoot>
          </table>
        </div>

        <div class="formula" id="formulaBox"></div>

        <div class="note">
          Tip: Try adding a low-EB SLO with a high weight (tier p0) to see how it drags the team score down.
        </div>
      </div>
        </div>

      <!-- ========== CONTAINER VULNS SECTION ========== -->
      <h2 class="section-title" id="section-vulns" style="margin-top: 32px;">Container Vulns</h2>

    <div class="intro-box">
      <h3>Score design</h3>
      <p>
        Container vulnerabilities are counted by severity: <strong>Critical</strong>, <strong>High</strong>, 
        <strong>Medium</strong>, and <strong>Low</strong>. Unlike SLO error budgets (which are already percentages), 
        vulnerability counts are unbounded numbers that need to be <em>normalized</em> into a 0‚Äì1 score.
      </p>
      
      <h4>Key design decisions</h4>
      <ul>
        <li>
          <strong>Aggregate by severity, not by image.</strong> 
          We sum all critical vulns across all images, all highs across all images, etc. 
          This ensures that 100 critical vulns has massive impact regardless of how they're distributed across images.
        </li>
        <li>
          <strong>Weight by severity.</strong>
          Critical vulns are weighted more heavily than low vulns (default: Critical=4, High=2, Medium=1, Low=0.5).
          This reflects the real-world urgency of different severity levels.
        </li>
        <li>
          <strong>Choose a normalization method.</strong>
          Different methods have different characteristics‚Äîexponential decay is smooth, 
          linear threshold has a hard cutoff, etc. The right choice depends on how you want to model urgency.
        </li>
      </ul>

      <h4>Recommendation: Exponential decay (Œª = 0.85)</h4>
      <p>
        We recommend <strong>exponential decay</strong> with a decay rate of <strong>0.85</strong> for normalizing vulnerability counts. 
        This means each additional vulnerability multiplies your score by 0.85 (a 15% reduction per vuln).
      </p>
      <p><strong>Why this method?</strong></p>
      <ul>
        <li>
          <strong>Diminishing returns.</strong> The first vulnerability hurts most (1.0 ‚Üí 0.85). 
          Going from 10 ‚Üí 11 vulns matters less (0.20 ‚Üí 0.17). This reflects reality: 
          a team with zero vulns slipping to one is a bigger deal than 50 ‚Üí 51.
        </li>
        <li>
          <strong>Never reaches zero.</strong> Even with many vulnerabilities, the score asymptotically 
          approaches zero but never quite gets there. This avoids the "give up" effect of hard cutoffs.
        </li>
        <li>
          <strong>Intuitive and explainable.</strong> "Each vulnerability reduces your score by 15%" 
          is easy to communicate to teams.
        </li>
        <li>
          <strong>Smooth curve.</strong> No arbitrary thresholds or discontinuities that could 
          feel unfair or gameable.
        </li>
      </ul>
      <p class="muted" style="margin-top: 8px;">
        With Œª = 0.85: 0 vulns ‚Üí 1.00, 1 ‚Üí 0.85, 3 ‚Üí 0.61, 5 ‚Üí 0.44, 10 ‚Üí 0.20, 20 ‚Üí 0.04
      </p>
      
      <p class="muted" style="margin-bottom: 0;">
        Use the controls below to experiment with different methods and parameters.
      </p>
    </div>

    <div class="grid">
      <!-- Configuration -->
      <div class="card">
        <h2>Configuration</h2>

        <div class="config-group">
          <div class="config-label">Severity weights</div>
          <div class="row">
            <label>Critical <input id="vulnWCritical" type="number" step="0.1" value="4.0" /></label>
            <label>High <input id="vulnWHigh" type="number" step="0.1" value="2.0" /></label>
            <label>Medium <input id="vulnWMedium" type="number" step="0.1" value="1.0" /></label>
            <label>Low <input id="vulnWLow" type="number" step="0.1" value="0.5" /></label>
          </div>
          </div>

        <div class="config-group" style="margin-top: 14px;">
          <div class="config-label">Score budget</div>
          <div class="row">
            <input id="vulnBudget" type="number" min="0" max="100" step="1" value="30" style="width: 80px;" />
            <span class="muted">/100 (global)</span>
        </div>
      </div>

        <div class="config-group" style="margin-top: 14px;">
          <div class="config-label">Normalization method</div>
          <select id="vulnMethod" style="width: 100%; max-width: 300px;">
            <option value="exponential">Exponential decay</option>
            <option value="linear">Linear threshold</option>
            <option value="inverse">Inverse (hyperbolic)</option>
            <option value="logarithmic">Logarithmic</option>
            <option value="sigmoid">Sigmoid (S-curve)</option>
            <option value="bucket">Bucket / Step function</option>
          </select>
        </div>

        <div class="method-params" id="vulnMethodParams">
          <!-- Dynamically populated based on selected method -->
        </div>

        <div class="chart-container" style="margin-top: 14px;">
          <div class="config-label" style="margin-bottom: 8px;">Normalization curve</div>
          <div style="position: relative; height: 200px;">
            <canvas id="vulnChart"></canvas>
          </div>
          <div class="row" style="margin-top: 8px; gap: 8px;">
            <label style="font-size: 12px;">
              <input type="checkbox" id="vulnShowAllMethods" /> Show all methods
            </label>
          </div>
        </div>
      </div>

      <!-- Inputs -->
      <div class="card">
        <h2>Inputs</h2>

        <table>
          <thead>
            <tr>
              <th>Image</th>
              <th>Critical</th>
              <th>High</th>
              <th>Medium</th>
              <th>Low</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="vulnTbody"></tbody>
        </table>

        <div class="row" style="justify-content: flex-end; margin-top: 12px;">
          <button class="btn" id="addVuln">+ Add Image</button>
        </div>
      </div>

      <!-- Results -->
      <div class="card">
        <h2>Results</h2>

        <div class="kpi">
          <div class="box">
            <div class="label">Weighted average <span class="mono">S</span> (0..1)</div>
            <div class="value mono" id="vulnScoreS">0.0000</div>
            <div class="bar" style="margin-top: 10px;"><div id="vulnScoreBar"></div></div>
          </div>
          <div class="box">
            <div class="label">Score (0..<span id="vulnScoreMax">20</span>)</div>
            <div class="value mono" id="vulnScore">0.00</div>
            <div class="small muted" id="vulnScoreNote"></div>
          </div>
        </div>

        <div class="aggregate-viz">
          <div class="agg-header">
            <span class="title">Weighted aggregate</span>
            <span class="formula-inline mono">S = Œ£(w·µ¢¬∑s·µ¢) / Œ£(w·µ¢)</span>
          </div>
          <table class="agg-table" id="vulnAggTable">
            <thead></thead>
            <tbody></tbody>
            <tfoot></tfoot>
          </table>
        </div>

        <div class="formula" id="vulnFormulaBox"></div>
      </div>
    </div>

      <!-- ========== BUG REPORTS SECTION ========== -->
      <h2 class="section-title" id="section-bugs" style="margin-top: 32px;">Bug Reports</h2>

    <div class="intro-box">
      <h3>Score design</h3>
      <p>
        Bug reports are tracked as individual tickets, each assigned a priority level: <strong>P0</strong> (critical/outage), 
        <strong>P1</strong> (high impact), or <strong>P2</strong> (moderate). Bug counts are unbounded numbers 
        that need to be <em>normalized</em> into a 0‚Äì1 score.
      </p>
      
      <h4>Key design decisions</h4>
      <ul>
        <li>
          <strong>Individual ticket tracking.</strong> 
          Enter each bug ticket with its assigned priority. The system aggregates 
          counts by priority level for scoring.
        </li>
        <li>
          <strong>Weight by priority.</strong>
          P0 bugs are weighted most heavily (default: P0=4, P1=2, P2=1).
          A single P0 outage bug should hurt more than several P2 polish issues.
        </li>
        <li>
          <strong>Choose a normalization method.</strong>
          Different methods have different characteristics‚Äîexponential decay is smooth, 
          linear threshold has a hard cutoff, etc. The right choice depends on how you want to model urgency.
        </li>
      </ul>

      <h4>Recommendation: Exponential decay (Œª = 0.85)</h4>
      <p>
        We recommend <strong>exponential decay</strong> with a decay rate of <strong>0.85</strong>. 
        Each additional bug reduces the score by 15%. Other methods are available for different team needs.
      </p>
      <p class="muted" style="margin-bottom: 0;">
        With Œª = 0.85: 0 bugs ‚Üí 1.00, 1 ‚Üí 0.85, 3 ‚Üí 0.61, 5 ‚Üí 0.44, 10 ‚Üí 0.20
      </p>
    </div>

    <div class="grid">
      <!-- Configuration -->
      <div class="card">
        <h2>Configuration</h2>

        <div class="config-group">
          <span class="config-label">Priority weights</span>
          <div class="row">
            <label>P0 <input type="number" id="bugWP0" step="0.5" min="0" value="4" style="width:60px"></label>
            <label>P1 <input type="number" id="bugWP1" step="0.5" min="0" value="2" style="width:60px"></label>
            <label>P2 <input type="number" id="bugWP2" step="0.5" min="0" value="1" style="width:60px"></label>
          </div>
        </div>

        <div class="config-group">
          <span class="config-label">Score budget</span>
          <input type="number" id="bugBudget" min="1" step="1" value="20" style="width:70px">
        </div>

        <div class="config-group" style="margin-top: 14px;">
          <div class="config-label">Normalization method</div>
          <select id="bugMethod" style="width: 100%; max-width: 300px;">
            <option value="exponential">Exponential decay</option>
            <option value="linear">Linear threshold</option>
            <option value="inverse">Inverse (hyperbolic)</option>
            <option value="logarithmic">Logarithmic</option>
            <option value="sigmoid">Sigmoid (S-curve)</option>
            <option value="bucket">Bucket / Step function</option>
          </select>
        </div>

        <div class="method-params" id="bugMethodParams">
          <!-- Dynamically populated based on selected method -->
        </div>

        <div class="chart-container" style="margin-top: 14px;">
          <div class="config-label" style="margin-bottom: 8px;">Normalization curve</div>
          <div style="position: relative; height: 200px;">
            <canvas id="bugChart"></canvas>
          </div>
          <div class="row" style="margin-top: 8px; gap: 8px;">
            <label style="font-size: 12px;">
              <input type="checkbox" id="bugShowAllMethods" />
              Show all methods
            </label>
          </div>
        </div>
      </div>

      <!-- Inputs -->
      <div class="card">
        <h2>Inputs</h2>
        <p class="muted" style="font-size: 12px; margin: 0 0 10px;">Enter individual bug tickets with their priority assignment.</p>

        <table>
          <thead>
            <tr>
              <th>Ticket</th>
              <th>Priority</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="bugTbody"></tbody>
        </table>

        <div class="row" style="justify-content: flex-end; margin-top: 12px;">
          <button class="btn" id="addBug">+ Add Ticket</button>
        </div>
      </div>

      <!-- Results -->
      <div class="card">
        <h2>Results</h2>

        <div class="kpi">
          <div class="box">
            <div class="label">Weighted average <span class="mono">S</span> (0..1)</div>
            <div class="value mono" id="bugScoreS">0.0000</div>
            <div class="bar" style="margin-top: 10px;"><div id="bugScoreBar"></div></div>
          </div>
          <div class="box">
            <div class="label">Score (0..<span id="bugScoreMax">20</span>)</div>
            <div class="value mono" id="bugScore">0.00</div>
            <div class="small muted" id="bugScoreNote"></div>
          </div>
        </div>

        <div class="aggregate-viz" style="margin-top: 14px;">
          <h3 style="font-size: 13px; margin: 0 0 8px; color: var(--muted);">Weighted aggregate</h3>
          <table class="agg-table" id="bugAggTable">
            <thead></thead>
            <tbody></tbody>
            <tfoot></tfoot>
          </table>
        </div>

        <div class="formula" id="bugFormulaBox"></div>
      </div>
    </div>

      <!-- ========== POSTMORTEMS SECTION ========== -->
      <h2 class="section-title" id="section-postmortems" style="margin-top: 32px;">Postmortems</h2>

    <div class="intro-box">
      <h3>Score design</h3>
      <p>
        Postmortem quality is measured across three problem types: <strong>Incomplete postmortem</strong> (most critical), 
        <strong>Incomplete action items</strong>, and <strong>Missing metadata</strong> (least critical). 
        Each problem is entered individually with its incident, severity, type, and description.
      </p>
      
      <h4>Key design decisions</h4>
      <ul>
        <li>
          <strong>Individual problem tracking.</strong> 
          Enter each problem separately with its associated incident and severity. 
          Problems are aggregated by type to measure team-wide hygiene.
        </li>
        <li>
          <strong>Weight by both severity and problem type.</strong>
          A Sev1 incomplete postmortem is more urgent than a Sev4 missing metadata. 
          We use multiplicative weighting: weighted_count = Œ£(severity_weight √ó 1).
        </li>
        <li>
          <strong>Choose a normalization method.</strong>
          Different methods have different characteristics‚Äîexponential decay is smooth, 
          linear threshold has a hard cutoff, etc. The right choice depends on how you want to model urgency.
        </li>
        <li>
          <strong>Weighted average across types.</strong>
          The final score is a weighted average of the three problem type scores, 
          with incomplete postmortems weighted most heavily.
        </li>
      </ul>
      
      <h4>Example calculation</h4>
      <p class="muted" style="margin-bottom: 0;">
        <strong>Problem 1:</strong> ALERT-4721 (Sev1), incomplete actions ‚Üí contributes 4 to actions<br>
        <strong>Problem 2:</strong> ALERT-3892 (Sev2), missing metadata ‚Üí contributes 2 to metadata<br>
        <strong>Problem 3:</strong> ALERT-1547 (Sev3), incomplete postmortem ‚Üí contributes 1 to postmortem<br><br>
        Weighted totals: metadata=2, actions=4, postmortem=1<br>
        Type scores (Œª=0.85): metadata=0.72, actions=0.52, postmortem=0.85<br>
        Final S = (1√ó0.72 + 2√ó0.52 + 3√ó0.85) / (1+2+3) = 0.72
      </p>
    </div>

    <div class="grid">
      <!-- Configuration -->
      <div class="card">
        <h2>Configuration</h2>

        <div class="config-group">
          <span class="config-label">Severity weights</span>
          <div class="row">
            <label>Sev1 <input type="number" id="pmWSev1" step="0.5" min="0" value="4" style="width:60px"></label>
            <label>Sev2 <input type="number" id="pmWSev2" step="0.5" min="0" value="2" style="width:60px"></label>
            <label>Sev3 <input type="number" id="pmWSev3" step="0.5" min="0" value="1" style="width:60px"></label>
            <label>Sev4 <input type="number" id="pmWSev4" step="0.5" min="0" value="0.5" style="width:60px"></label>
          </div>
        </div>

        <div class="config-group" style="margin-top: 14px;">
          <span class="config-label">Problem type weights</span>
          <div class="row">
            <label>Incomplete postmortem <input type="number" id="pmWPostmortem" step="0.5" min="0" value="3" style="width:60px"></label>
            <label>Incomplete actions <input type="number" id="pmWActions" step="0.5" min="0" value="2" style="width:60px"></label>
            <label>Missing metadata <input type="number" id="pmWMetadata" step="0.5" min="0" value="1" style="width:60px"></label>
          </div>
        </div>

        <div class="config-group" style="margin-top: 14px;">
          <span class="config-label">Score budget</span>
          <input type="number" id="pmBudget" min="1" step="1" value="15" style="width:70px">
        </div>

        <div class="config-group" style="margin-top: 14px;">
          <div class="config-label">Normalization method</div>
          <select id="pmMethod" style="width: 100%; max-width: 300px;">
            <option value="exponential">Exponential decay</option>
            <option value="linear">Linear threshold</option>
            <option value="inverse">Inverse (hyperbolic)</option>
            <option value="logarithmic">Logarithmic</option>
            <option value="sigmoid">Sigmoid (S-curve)</option>
            <option value="bucket">Bucket / Step function</option>
          </select>
        </div>

        <div class="method-params" id="pmMethodParams">
          <!-- Dynamically populated based on selected method -->
        </div>

        <div class="chart-container" style="margin-top: 14px;">
          <div class="config-label" style="margin-bottom: 8px;">Normalization curve</div>
          <div style="position: relative; height: 200px;">
            <canvas id="pmChart"></canvas>
          </div>
          <div class="row" style="margin-top: 8px; gap: 8px;">
            <label style="font-size: 12px;">
              <input type="checkbox" id="pmShowAllMethods" />
              Show all methods
            </label>
          </div>
        </div>
      </div>

      <!-- Inputs -->
      <div class="card">
        <h2>Inputs</h2>
        <p class="muted" style="font-size: 12px; margin: 0 0 10px;">Enter individual postmortem problems. Scoring aggregates by problem type across all incidents.</p>

        <table>
          <thead>
            <tr>
              <th>Incident</th>
              <th>Severity</th>
              <th>Problem Type</th>
              <th>Description</th>
              <th></th>
            </tr>
          </thead>
          <tbody id="pmTbody"></tbody>
        </table>

        <div class="row" style="justify-content: flex-end; margin-top: 12px;">
          <button class="btn" id="addPm">+ Add Problem</button>
        </div>
      </div>

      <!-- Results -->
      <div class="card">
        <h2>Results</h2>

        <div class="kpi">
          <div class="box">
            <div class="label">Weighted average <span class="mono">S</span> (0..1)</div>
            <div class="value mono" id="pmScoreS">0.0000</div>
            <div class="bar" style="margin-top: 10px;"><div id="pmScoreBar"></div></div>
          </div>
          <div class="box">
            <div class="label">Score (0..<span id="pmScoreMax">20</span>)</div>
            <div class="value mono" id="pmScore">0.00</div>
            <div class="small muted" id="pmScoreNote"></div>
          </div>
        </div>

        <div class="aggregate-viz" style="margin-top: 14px;">
          <h3 style="font-size: 13px; margin: 0 0 8px; color: var(--muted);">Weighted aggregate by problem type</h3>
          <table class="agg-table" id="pmAggTable">
            <thead></thead>
            <tbody></tbody>
            <tfoot></tfoot>
          </table>
        </div>

        <div class="formula" id="pmFormulaBox"></div>
      </div>
    </div>
    </div><!-- /wrap -->
  </div><!-- /page-layout -->

<script>
  // ---------- Helpers (from shared compute module) ----------
  const clamp = window.ScorecardCompute.clamp;
  const fmt = window.ScorecardCompute.fmt;
  const fmt2 = window.ScorecardCompute.fmt2;
  const getScoreClassSimple = window.ScorecardCompute.getScoreClassSimple;
  const getLetterGrade = window.ScorecardCompute.getLetterGrade;

  // ---------- Normalization Methods (from shared config module) ----------
  const normMethods = window.ScorecardConfig.normMethods;
  
  /* Original inline definition (now in scorecard-config.js):
  const normMethods = {
    exponential: {
      name: "Exponential decay",
      calc: (count, params) => Math.pow(params.decay, count),
      formula: (params) => `s·µ¢ = ${params.decay}^count`,
      examples: (params) => {
        const d = params.decay;
        return `0 ‚Üí 1.00, 1 ‚Üí ${fmt2(Math.pow(d,1))}, 3 ‚Üí ${fmt2(Math.pow(d,3))}, 5 ‚Üí ${fmt2(Math.pow(d,5))}, 10 ‚Üí ${fmt2(Math.pow(d,10))}`;
      }
    },
    linear: {
      name: "Linear threshold",
      calc: (count, params) => Math.max(0, 1 - count / params.threshold),
      formula: (params) => `s·µ¢ = max(0, 1 - count / ${params.threshold})`,
      examples: (params) => {
        const t = params.threshold;
        return `0 ‚Üí 1.00, ${Math.floor(t/2)} ‚Üí ${fmt2(0.5)}, ${t} ‚Üí 0.00, ${t+5} ‚Üí 0.00`;
      }
    },
    inverse: {
      name: "Inverse (hyperbolic)",
      calc: (count, params) => 1 / (1 + params.k * count),
      formula: (params) => `s·µ¢ = 1 / (1 + ${params.k} √ó count)`,
      examples: (params) => {
        const k = params.k;
        const f = c => 1 / (1 + k * c);
        return `0 ‚Üí 1.00, 1 ‚Üí ${fmt2(f(1))}, 3 ‚Üí ${fmt2(f(3))}, 5 ‚Üí ${fmt2(f(5))}, 10 ‚Üí ${fmt2(f(10))}`;
      }
    },
    logarithmic: {
      name: "Logarithmic",
      calc: (count, params) => Math.max(0, 1 - Math.log(1 + count) / Math.log(1 + params.maxExpected)),
      formula: (params) => `s·µ¢ = max(0, 1 - log(1+count) / log(1+${params.maxExpected}))`,
      examples: (params) => {
        const m = params.maxExpected;
        const f = c => Math.max(0, 1 - Math.log(1+c) / Math.log(1+m));
        return `0 ‚Üí 1.00, 1 ‚Üí ${fmt2(f(1))}, 5 ‚Üí ${fmt2(f(5))}, ${m} ‚Üí 0.00`;
      }
    },
    sigmoid: {
      name: "Sigmoid (S-curve)",
      calc: (count, params) => 1 / (1 + Math.exp(params.steepness * (count - params.midpoint))),
      formula: (params) => `s·µ¢ = 1 / (1 + e^(${params.steepness} √ó (count - ${params.midpoint})))`,
      examples: (params) => {
        const f = c => 1 / (1 + Math.exp(params.steepness * (c - params.midpoint)));
        return `0 ‚Üí ${fmt2(f(0))}, ${params.midpoint} ‚Üí 0.50, ${params.midpoint * 2} ‚Üí ${fmt2(f(params.midpoint * 2))}`;
      }
    },
    bucket: {
      name: "Bucket / Step function",
      calc: (count, params) => {
        const buckets = params.buckets; // [[threshold, score], ...]
        let score = 1.0;
        for (const [thresh, s] of buckets) {
          if (count >= thresh) score = s;
        }
        return score;
      },
      formula: (params) => `Step function with ${params.buckets.length} buckets`,
      examples: (params) => {
        return params.buckets.map(([t, s]) => `${t}+ ‚Üí ${fmt2(s)}`).join(", ");
      }
    }
  };
  */

  // Method colors for charts
  const methodColors = {
    exponential: { border: "#6ee7b7", bg: "rgba(110,231,183,0.1)" },
    linear: { border: "#fb7185", bg: "rgba(251,113,133,0.1)" },
    inverse: { border: "#93c5fd", bg: "rgba(147,197,253,0.1)" },
    logarithmic: { border: "#fde68a", bg: "rgba(253,230,138,0.1)" },
    sigmoid: { border: "#c4b5fd", bg: "rgba(196,181,253,0.1)" },
    bucket: { border: "#fdba74", bg: "rgba(253,186,116,0.1)" }
  };

  // ---------- Shared Method Params Utilities ----------
  // These utilities eliminate duplication across SLO, Vuln, Bug, and PM sections
  
  /**
   * Renders method parameter inputs for any scoring category.
   * @param {Object} config - Configuration object
   * @param {string} config.prefix - ID prefix (e.g., "slo", "vuln", "bug", "pm")
   * @param {Object} config.stateObj - The state object containing method and params
   * @param {HTMLElement} config.containerEl - DOM element to render into
   * @param {Function} config.recomputeFn - Function to call when params change
   * @param {Function} [config.renderChartFn] - Optional chart render function
   * @param {Object} [config.descriptions] - Optional custom descriptions per method
   */
  function renderMethodParams(config) {
    const { prefix, stateObj, containerEl, recomputeFn, renderChartFn, descriptions = {} } = config;
    
    // Ensure method and params exist
    if (!stateObj.method || !stateObj.params || !stateObj.params[stateObj.method]) {
      stateObj.method = "exponential";
      if (!stateObj.params) {
        stateObj.params = {
          exponential: { decay: 0.85 },
          linear: { threshold: 10 },
          inverse: { k: 1.0 },
          logarithmic: { maxExpected: 20 },
          sigmoid: { midpoint: 5, steepness: 1.0 },
          bucket: { buckets: [[0, 1.0], [1, 0.8], [3, 0.5], [6, 0.2], [11, 0.0]] }
        };
      }
    }
    
    const method = stateObj.method;
    const params = stateObj.params[method];
    const methodInfo = normMethods[method];
    
    // Default descriptions for each method type
    const defaultDescriptions = {
      exponential: "Each unit multiplies score by this",
      linear: "Count at which score = 0",
      inverse: "Higher = faster drop",
      logarithmic: "Count at which score = 0",
      sigmoid: { midpoint: "Count where score = 0.5", steepness: "Higher = sharper transition" },
      bucket: "Bucket definitions (count threshold ‚Üí score)"
    };
    const desc = { ...defaultDescriptions, ...descriptions };
    
    let html = "";
    
    if (method === "exponential") {
      html = `
        <div class="param-row">
          <span class="param-label">Decay rate:</span>
          <input type="number" id="${prefix}ParamDecay" step="0.05" min="0.1" max="0.99" value="${params.decay}" style="width: 80px;" />
          <span class="muted small">${desc.exponential}</span>
        </div>
      `;
    } else if (method === "linear") {
      html = `
        <div class="param-row">
          <span class="param-label">Threshold:</span>
          <input type="number" id="${prefix}ParamThreshold" step="1" min="1" value="${params.threshold}" style="width: 80px;" />
          <span class="muted small">${desc.linear}</span>
        </div>
      `;
    } else if (method === "inverse") {
      html = `
        <div class="param-row">
          <span class="param-label">Steepness (k):</span>
          <input type="number" id="${prefix}ParamK" step="0.1" min="0.1" value="${params.k}" style="width: 80px;" />
          <span class="muted small">${desc.inverse}</span>
        </div>
      `;
    } else if (method === "logarithmic") {
      html = `
        <div class="param-row">
          <span class="param-label">Max expected:</span>
          <input type="number" id="${prefix}ParamMax" step="1" min="1" value="${params.maxExpected}" style="width: 80px;" />
          <span class="muted small">${desc.logarithmic}</span>
        </div>
      `;
    } else if (method === "sigmoid") {
      const sigmoidDesc = typeof desc.sigmoid === "object" ? desc.sigmoid : { midpoint: desc.sigmoid, steepness: "Higher = sharper transition" };
      html = `
        <div class="param-row">
          <span class="param-label">Midpoint:</span>
          <input type="number" id="${prefix}ParamMidpoint" step="1" min="1" value="${params.midpoint}" style="width: 80px;" />
          <span class="muted small">${sigmoidDesc.midpoint}</span>
        </div>
        <div class="param-row">
          <span class="param-label">Steepness:</span>
          <input type="number" id="${prefix}ParamSteepness" step="0.1" min="0.1" value="${params.steepness}" style="width: 80px;" />
          <span class="muted small">${sigmoidDesc.steepness}</span>
        </div>
      `;
    } else if (method === "bucket") {
      html = `
        <div class="param-row">
          <span class="muted small">${desc.bucket}:</span>
        </div>
        <div class="param-row" style="flex-wrap: wrap; gap: 6px;">
          ${params.buckets.map(([t, s]) => `
            <span class="mono" style="background: rgba(255,255,255,.1); padding: 4px 8px; border-radius: 6px;">
              ${t}+ ‚Üí ${fmt2(s)}
            </span>
          `).join("")}
        </div>
      `;
    }
    
    // Add formula and examples display
    html += `
      <div class="formula-display" id="${prefix}ParamFormula">Formula: ${methodInfo.formula(params)}</div>
      <div class="example-display" id="${prefix}ParamExample">Example: ${methodInfo.examples(params)}</div>
    `;
    
    containerEl.innerHTML = html;
    
    // Attach event listeners
    attachMethodParamListeners(config);
  }
  
  /**
   * Updates the formula and examples display for a category.
   */
  function updateFormulaDisplay(config) {
    const { prefix, stateObj } = config;
    const method = stateObj.method;
    const params = stateObj.params[method];
    const methodInfo = normMethods[method];
    
    const formulaEl = document.getElementById(`${prefix}ParamFormula`);
    const exampleEl = document.getElementById(`${prefix}ParamExample`);
    
    if (formulaEl) formulaEl.textContent = `Formula: ${methodInfo.formula(params)}`;
    if (exampleEl) exampleEl.textContent = `Example: ${methodInfo.examples(params)}`;
  }
  
  /**
   * Attaches event listeners to method parameter inputs.
   */
  function attachMethodParamListeners(config) {
    const { prefix, stateObj, recomputeFn, renderChartFn } = config;
    const method = stateObj.method;
    
    const handleChange = () => {
      updateFormulaDisplay(config);
      recomputeFn();
      if (renderChartFn) renderChartFn();
    };
    
    if (method === "exponential") {
      const inp = document.getElementById(`${prefix}ParamDecay`);
      if (inp) inp.addEventListener("input", () => {
        stateObj.params.exponential.decay = Number(inp.value) || 0.85;
        handleChange();
      });
    } else if (method === "linear") {
      const inp = document.getElementById(`${prefix}ParamThreshold`);
      if (inp) inp.addEventListener("input", () => {
        stateObj.params.linear.threshold = Number(inp.value) || 10;
        handleChange();
      });
    } else if (method === "inverse") {
      const inp = document.getElementById(`${prefix}ParamK`);
      if (inp) inp.addEventListener("input", () => {
        stateObj.params.inverse.k = Number(inp.value) || 1;
        handleChange();
      });
    } else if (method === "logarithmic") {
      const inp = document.getElementById(`${prefix}ParamMax`);
      if (inp) inp.addEventListener("input", () => {
        stateObj.params.logarithmic.maxExpected = Number(inp.value) || 20;
        handleChange();
      });
    } else if (method === "sigmoid") {
      const mid = document.getElementById(`${prefix}ParamMidpoint`);
      const steep = document.getElementById(`${prefix}ParamSteepness`);
      if (mid) mid.addEventListener("input", () => {
        stateObj.params.sigmoid.midpoint = Number(mid.value) || 5;
        handleChange();
      });
      if (steep) steep.addEventListener("input", () => {
        stateObj.params.sigmoid.steepness = Number(steep.value) || 1;
        handleChange();
      });
    }
    // Note: bucket method doesn't have editable inputs in the current implementation
  }
  
  /**
   * Sets up the method dropdown change handler for a category.
   * @param {Object} config - Same config as renderMethodParams
   * @param {HTMLElement} config.methodSelectEl - The method dropdown element
   */
  function setupMethodChangeHandler(config) {
    const { stateObj, methodSelectEl, recomputeFn, renderChartFn } = config;
    
    methodSelectEl.addEventListener("change", () => {
      stateObj.method = methodSelectEl.value;
      renderMethodParams(config);
      recomputeFn();
      if (renderChartFn) renderChartFn();
    });
  }

  // ---------- Opportunity Calculation ----------
  // Calculate opportunities for each item across all categories
  // Uses the shared function from scorecard-compute.js
  function calculateOpportunities() {
    try {
      // Build team data from current state
      const teamData = {
        slos: (typeof state !== 'undefined' && state.slos) ? state.slos : [],
        images: (typeof vulnState !== 'undefined' && vulnState.images) ? vulnState.images : [],
        tickets: (typeof bugState !== 'undefined' && bugState.tickets) ? bugState.tickets : [],
        problems: (typeof pmState !== 'undefined' && pmState.problems) ? pmState.problems : []
      };
      
      // Build config from current state
      const currentConfig = {
        slo: {
          pointBudget: state?.pointBudget || 35,
          tierWeights: state?.tierWeights || { p0: 2, p1: 1, p2: 0.5 },
          method: state?.method || 'exponential',
          params: state?.params || { exponential: { decay: 0.85 } }
        },
        vuln: {
          budget: vulnState?.budget || 30,
          weights: vulnState?.weights || { critical: 4, high: 2, medium: 1, low: 0.5 },
          method: vulnState?.method || 'exponential',
          params: vulnState?.params || { exponential: { decay: 0.85 } }
        },
        bug: {
          budget: bugState?.budget || 20,
          weights: bugState?.weights || { p0: 4, p1: 2, p2: 1 },
          method: bugState?.method || 'exponential',
          params: bugState?.params || { exponential: { decay: 0.85 } }
        },
        pm: {
          budget: pmState?.budget || 15,
          severityWeights: pmState?.severityWeights || { sev1: 4, sev2: 2, sev3: 1, sev4: 0.5 },
          typeWeights: pmState?.typeWeights || { postmortem: 3, actions: 2, metadata: 1 },
          method: pmState?.method || 'exponential',
          params: pmState?.params || { exponential: { decay: 0.85 } }
        }
      };
      
      // Use the shared function from scorecard-compute.js
      const opportunities = window.ScorecardCompute.calculateOpportunities(teamData, currentConfig, normMethods, '');
      
      // Add link property for navigation within the page
      opportunities.forEach(opp => {
        if (opp.itemId) {
          const [category, idx] = opp.itemId.split('-');
          opp.link = `#${category}-row-${idx}`;
        }
      });
      
      return opportunities;
    } catch (e) {
      // State not yet initialized, return empty
      return [];
    }
  }

  // ---------- Persistence ----------
  let allSectionsInitialized = false;

  function saveAllState() {
    if (!allSectionsInitialized || !currentTeamPath) return;
    
    try {
      // Save configuration changes
      window.ScorecardConfig.updateCategoryConfig('slo', {
        pointBudget: state.pointBudget,
        tierWeights: state.tierWeights,
        method: state.method,
        params: state.params
      });
      window.ScorecardConfig.updateCategoryConfig('vuln', {
        budget: vulnState.budget,
        weights: vulnState.weights,
        method: vulnState.method,
        params: vulnState.params
      });
      window.ScorecardConfig.updateCategoryConfig('bug', {
        budget: bugState.budget,
        weights: bugState.weights,
        method: bugState.method,
        params: bugState.params
      });
      window.ScorecardConfig.updateCategoryConfig('pm', {
        budget: pmState.budget,
        severityWeights: pmState.severityWeights,
        typeWeights: pmState.typeWeights,
        method: pmState.method,
        params: pmState.params
      });
      
      // Save team data changes
      saveTeamData(currentTeamPath, {
        slos: state.slos,
        images: vulnState.images,
        tickets: bugState.tickets,
        problems: pmState.problems
      });
    } catch (e) {
      console.warn("Could not save state:", e);
    }
  }

  // ---------- State ----------
  // Load shared configuration
  const sharedConfig = window.ScorecardConfig.loadConfig();
  
  // Current selected team path
  let currentTeamPath = null;
  
  // Load team data from mock data
  function loadTeamData(path) {
    const teamData = window.MockData.getMockDataForTeam(path);
    if (!teamData) return null;
    
    return {
      slos: teamData.slos || [],
      images: teamData.images || [],
      tickets: teamData.tickets || [],
      problems: teamData.problems || []
    };
  }
  
  // Save team data to mock data
  function saveTeamData(path, data) {
    const teamData = {
      slos: data.slos || [],
      images: data.images || [],
      tickets: data.tickets || [],
      problems: data.problems || []
    };
    window.MockData.updateMockDataForTeam(path, teamData);
  }

  // Initialize state from first team
  const allTeams = window.MockData.getAllTeamPaths();
  currentTeamPath = allTeams[0]?.path || null;
  
  const initialTeamData = currentTeamPath ? loadTeamData(currentTeamPath) : { slos: [], images: [], tickets: [], problems: [] };
  
  let state = {
    pointBudget: sharedConfig.slo.pointBudget,
    tierWeights: sharedConfig.slo.tierWeights,
    method: sharedConfig.slo.method,
    params: sharedConfig.slo.params,
    slos: initialTeamData.slos
  };

  // ---------- DOM ----------
  const el = {
    pointBudget: document.getElementById("pointBudget"),
    wP0: document.getElementById("wP0"),
    wP1: document.getElementById("wP1"),
    wP2: document.getElementById("wP2"),
    method: document.getElementById("sloMethod"),
    methodParams: document.getElementById("sloMethodParams"),
    chartCanvas: document.getElementById("sloChart"),
    showAllMethods: document.getElementById("sloShowAllMethods"),
    addSlo: document.getElementById("addSlo"),
    sloTbody: document.getElementById("sloTbody"),
    scoreS: document.getElementById("scoreS"),
    scoreBar: document.getElementById("scoreBar"),
    points: document.getElementById("points"),
    pointsMax: document.getElementById("pointsMax"),
    pointsNote: document.getElementById("pointsNote"),
    aggTable: document.getElementById("aggTable"),
    formulaBox: document.getElementById("formulaBox"),
  };

  // Sidebar elements
  const sidebarEl = {
    // Grade badge
    gradeBadge: document.getElementById("gradeBadge"),
    // Totals
    totalScore: document.getElementById("sidebarTotalScore"),
    totalMax: document.getElementById("sidebarTotalMax"),
    // Category rows
    sloScore: document.getElementById("sidebarSloScore"),
    sloPct: document.getElementById("sidebarSloPct"),
    sloBar: document.getElementById("sidebarSloBar"),
    vulnScore: document.getElementById("sidebarVulnScore"),
    vulnPct: document.getElementById("sidebarVulnPct"),
    vulnBar: document.getElementById("sidebarVulnBar"),
    bugsScore: document.getElementById("sidebarBugsScore"),
    bugsPct: document.getElementById("sidebarBugsPct"),
    bugsBar: document.getElementById("sidebarBugsBar"),
    pmScore: document.getElementById("sidebarPmScore"),
    pmPct: document.getElementById("sidebarPmPct"),
    pmBar: document.getElementById("sidebarPmBar"),
    // Priority work
    priorityItems: document.getElementById("priorityItems"),
  };

  // Store current scores for sidebar
  let currentScores = {
    slo: 0,
    sloMax: 20,
    vulns: 0,
    vulnsMax: 20,
    bugs: 0,
    bugsMax: 20,
    pm: 0,
    pmMax: 20,
  };

  function updateSidebar() {
    const total = currentScores.slo + currentScores.vulns + currentScores.bugs + currentScores.pm;
    const totalMax = currentScores.sloMax + currentScores.vulnsMax + currentScores.bugsMax + currentScores.pmMax;
    const totalPct = totalMax > 0 ? (total / totalMax) : 0;
    
    // Use shared helper functions from scorecard-compute.js
    const getScoreClass = getScoreClassSimple;
    const getGrade = (pct) => getLetterGrade(pct * 100);
    
    // Update grade badge
    const grade = getGrade(totalPct);
    sidebarEl.gradeBadge.textContent = grade;
    sidebarEl.gradeBadge.className = "grade-badge grade-" + grade;
    
    // Update total score
    sidebarEl.totalScore.textContent = Math.round(total);
    sidebarEl.totalMax.textContent = Math.round(totalMax);
    
    // Update category rows
    if (totalMax > 0) {
      const sloPct = currentScores.sloMax > 0 ? (currentScores.slo / currentScores.sloMax) : 0;
      const vulnPct = currentScores.vulnsMax > 0 ? (currentScores.vulns / currentScores.vulnsMax) : 0;
      const bugsPct = currentScores.bugsMax > 0 ? (currentScores.bugs / currentScores.bugsMax) : 0;
      const pmPct = currentScores.pmMax > 0 ? (currentScores.pm / currentScores.pmMax) : 0;
      
      // Update category rows
      // SLOs
      sidebarEl.sloScore.textContent = `${Math.round(currentScores.slo)} / ${Math.round(currentScores.sloMax)}`;
      sidebarEl.sloPct.textContent = Math.round(sloPct * 100) + "%";
      sidebarEl.sloPct.className = "category-pct " + getScoreClass(sloPct);
      sidebarEl.sloBar.className = "category-bar " + getScoreClass(sloPct);
      sidebarEl.sloBar.querySelector("div").style.width = (sloPct * 100).toFixed(1) + "%";
      
      // Vulns
      sidebarEl.vulnScore.textContent = `${Math.round(currentScores.vulns)} / ${Math.round(currentScores.vulnsMax)}`;
      sidebarEl.vulnPct.textContent = Math.round(vulnPct * 100) + "%";
      sidebarEl.vulnPct.className = "category-pct " + getScoreClass(vulnPct);
      sidebarEl.vulnBar.className = "category-bar " + getScoreClass(vulnPct);
      sidebarEl.vulnBar.querySelector("div").style.width = (vulnPct * 100).toFixed(1) + "%";
      
      // Bugs
      sidebarEl.bugsScore.textContent = `${Math.round(currentScores.bugs)} / ${Math.round(currentScores.bugsMax)}`;
      sidebarEl.bugsPct.textContent = Math.round(bugsPct * 100) + "%";
      sidebarEl.bugsPct.className = "category-pct " + getScoreClass(bugsPct);
      sidebarEl.bugsBar.className = "category-bar " + getScoreClass(bugsPct);
      sidebarEl.bugsBar.querySelector("div").style.width = (bugsPct * 100).toFixed(1) + "%";
      
      // Postmortems
      sidebarEl.pmScore.textContent = `${Math.round(currentScores.pm)} / ${Math.round(currentScores.pmMax)}`;
      sidebarEl.pmPct.textContent = Math.round(pmPct * 100) + "%";
      sidebarEl.pmPct.className = "category-pct " + getScoreClass(pmPct);
      sidebarEl.pmBar.className = "category-bar " + getScoreClass(pmPct);
      sidebarEl.pmBar.querySelector("div").style.width = (pmPct * 100).toFixed(1) + "%";
    }
    
    // Update priority work list with FLIP animation
    const opportunities = calculateOpportunities();
    const maxToShow = 5;
    const topOpportunities = opportunities.slice(0, maxToShow);
    
    if (topOpportunities.length === 0) {
      sidebarEl.priorityItems.innerHTML = '<div class="priority-empty">‚úì All items at max score!</div>';
    } else {
      // FLIP animation: First - record old positions and elements
      const oldItems = Array.from(sidebarEl.priorityItems.querySelectorAll('.priority-item'));
      const oldPositions = new Map();
      const oldIds = new Set();
      
      oldItems.forEach(item => {
        const id = item.dataset.itemId;
        if (id) {
          oldPositions.set(id, item.getBoundingClientRect());
          oldIds.add(id);
        }
      });
      
      // Get new item IDs
      const newIds = new Set(topOpportunities.map(opp => opp.itemId));
      
      // Last - update DOM
      sidebarEl.priorityItems.innerHTML = topOpportunities.map(opp => `
        <a href="${opp.link}" class="priority-item" data-item-id="${opp.itemId}">
          <div class="priority-item-header">
            <span class="priority-item-dot" style="background: ${opp.categoryColor};"></span>
            <span class="priority-item-category">${opp.category}</span>
            <span class="priority-item-opportunity">+${fmt2(opp.opportunity)} pts</span>
          </div>
          <div class="priority-item-name">${escapeHtml(opp.name)}</div>
        </a>
      `).join('');
      
      // Invert & Play - animate items that moved or are new
      const newItems = sidebarEl.priorityItems.querySelectorAll('.priority-item');
      
      newItems.forEach(item => {
        const id = item.dataset.itemId;
        const oldPos = oldPositions.get(id);
        
        if (oldPos) {
          // Item existed before - check if it moved
          const newPos = item.getBoundingClientRect();
          const deltaY = oldPos.top - newPos.top;
          
          if (Math.abs(deltaY) > 2) {
            // FLIP: Invert - set transform to old position (without transition)
            item.style.transform = `translateY(${deltaY}px)`;
            
            // Force reflow to ensure the transform is applied
            item.offsetHeight;
            
            // Play - add transition class and clear transform to animate
            item.classList.add('flip-animating');
            item.style.transform = '';
            
            // Cleanup after animation
            item.addEventListener('transitionend', function handler(e) {
              if (e.propertyName === 'transform') {
                item.classList.remove('flip-animating');
                item.removeEventListener('transitionend', handler);
              }
            });
          }
        } else {
          // New item - fade in with entrance animation
          item.classList.add('entering');
          item.addEventListener('animationend', function handler() {
            item.classList.remove('entering');
            item.removeEventListener('animationend', handler);
          });
        }
      });
    }
  }


  // ---------- Rendering ----------
  function weightForSlo(slo) {
    return Number(state.tierWeights[slo.tier] ?? 1.0);
  }

  function renderTable() {
    el.sloTbody.innerHTML = "";

    state.slos.forEach((slo, idx) => {
      const tr = document.createElement("tr");
      tr.id = `slo-row-${idx}`;  // Add unique ID for direct linking

      // Name
      const tdName = document.createElement("td");
      const name = document.createElement("input");
      name.type = "text";
      name.value = slo.name;
      name.addEventListener("input", () => { slo.name = name.value; recompute(); });
      tdName.appendChild(name);

      // EB%
      const tdEb = document.createElement("td");
      const eb = document.createElement("input");
      eb.type = "number";
      eb.min = "-100";
      eb.max = "100";
      eb.step = "1";
      eb.value = slo.ebPct;
      eb.addEventListener("input", () => { slo.ebPct = Number(eb.value); recompute(); });
      tdEb.appendChild(eb);

      // Tier
      const tdTier = document.createElement("td");
      const tier = document.createElement("select");
      ["p0","p1","p2"].forEach(t => {
        const opt = document.createElement("option");
        opt.value = t;
        opt.textContent = t;
        tier.appendChild(opt);
      });
      tier.value = slo.tier;
      tier.addEventListener("change", () => { slo.tier = tier.value; recompute(); });
      tdTier.appendChild(tier);

      // Remove
      const tdRm = document.createElement("td");
      const rm = document.createElement("button");
      rm.className = "btn danger";
      rm.textContent = "Remove";
      rm.addEventListener("click", () => {
        state.slos.splice(idx, 1);
        renderTable();
        recompute();
      });
      tdRm.appendChild(rm);

      [tdName, tdTier, tdEb, tdRm].forEach(td => tr.appendChild(td));
      el.sloTbody.appendChild(tr);
    });
  }

  function escapeHtml(s) {
    return String(s).replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
  }

  function renderAggregateViz(items, denom, numer, S) {
    const thead = el.aggTable.querySelector("thead");
    const tbody = el.aggTable.querySelector("tbody");
    const tfoot = el.aggTable.querySelector("tfoot");
    
    thead.innerHTML = "";
    tbody.innerHTML = "";
    tfoot.innerHTML = "";
    
    if (items.length === 0) {
      tbody.innerHTML = `<tr><td colspan="4" class="muted">No SLOs defined.</td></tr>`;
      return;
    }

    // Header
    thead.innerHTML = `
      <tr>
        <th>SLO</th>
        <th class="right">s·µ¢</th>
        <th class="right">w·µ¢</th>
        <th class="right">w·µ¢ ¬∑ s·µ¢</th>
      </tr>
    `;

    // Body rows
    items.forEach(it => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(it.name)}</td>
        <td class="mono right">${fmt(it.s, 4)}</td>
        <td class="mono right">${fmt(it.w, 2)}</td>
        <td class="mono right">${fmt(it.ws, 4)}</td>
      `;
      tbody.appendChild(tr);
    });

    // Footer with totals
    tfoot.innerHTML = `
      <tr>
        <td>Total</td>
        <td class="mono right muted">‚Äî</td>
        <td class="mono right">${fmt(denom, 2)}</td>
        <td class="mono right">${fmt(numer, 4)}</td>
      </tr>
      <tr>
        <td colspan="3" style="text-align: right; padding-right: 10px;">S = Œ£(w·µ¢¬∑s·µ¢) / Œ£(w·µ¢) =</td>
        <td class="mono right" style="font-size: 16px;">${fmt(S, 4)}</td>
      </tr>
    `;
  }

  // Chart instance for SLO normalization
  let sloChart = null;

  // ---------- Render SLO Chart ----------
  function renderSloChart() {
    const showAll = el.showAllMethods.checked;
    const currentMethod = state.method;
    
    // Generate labels from +100 to -100 (left to right)
    const labels = Array.from({ length: 201 }, (_, i) => 100 - i);
    const datasets = [];
    
    // Calculate score based on EB%: positive = 1.0, negative = apply penalty
    const calcScore = (ebPct, methodInfo, params) => {
      if (ebPct >= 0) return 1.0;
      return methodInfo.calc(Math.abs(ebPct), params);
    };
    
    if (showAll) {
      Object.entries(normMethods).forEach(([key, methodInfo]) => {
        const params = state.params[key];
        const data = labels.map(ebPct => calcScore(ebPct, methodInfo, params));
        const isSelected = key === currentMethod;
        
        datasets.push({
          label: methodInfo.name,
          data: data,
          borderColor: methodColors[key].border,
          backgroundColor: isSelected ? methodColors[key].bg : "transparent",
          borderWidth: isSelected ? 3 : 1.5,
          pointRadius: 0,
          tension: key === "bucket" ? 0 : 0.3,
          stepped: key === "bucket" ? "before" : false,
          fill: isSelected,
          order: isSelected ? 0 : 1
        });
      });
    } else {
      const params = state.params[currentMethod];
      const methodInfo = normMethods[currentMethod];
      const data = labels.map(ebPct => calcScore(ebPct, methodInfo, params));
      
      datasets.push({
        label: methodInfo.name,
        data: data,
        borderColor: methodColors[currentMethod].border,
        backgroundColor: methodColors[currentMethod].bg,
        borderWidth: 3,
        pointRadius: 0,
        tension: currentMethod === "bucket" ? 0 : 0.3,
        stepped: currentMethod === "bucket" ? "before" : false,
        fill: true
      });
    }
    
    if (sloChart) {
      sloChart.data.labels = labels;
      sloChart.data.datasets = datasets;
      sloChart.options.plugins.legend.display = showAll;
      sloChart.update("none");
    } else {
      sloChart = new Chart(el.chartCanvas, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: "index"
          },
          plugins: {
            legend: {
              display: showAll,
              position: "bottom",
              labels: {
                color: "#a9b4d6",
                font: { size: 11 },
                boxWidth: 12,
                padding: 8
              }
            },
            tooltip: {
              backgroundColor: "rgba(17,25,53,0.95)",
              titleColor: "#e9eefc",
              bodyColor: "#a9b4d6",
              borderColor: "rgba(255,255,255,0.1)",
              borderWidth: 1,
              padding: 10,
              callbacks: {
                title: (items) => `Error Budget: ${items[0].label}%`,
                label: (item) => `${item.dataset.label}: ${item.parsed.y.toFixed(4)}`
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Error Budget %",
                color: "#a9b4d6",
                font: { size: 11 }
              },
              ticks: { 
                color: "#a9b4d6", 
                font: { size: 10 },
                autoSkip: false,
                callback: function(value, index) {
                  const label = 100 - index; // labels go from 100 to -100
                  // Show ticks at intervals of 20
                  if (label % 20 === 0) return label + '%';
                  return null;
                },
                maxRotation: 0
              },
              grid: { color: "rgba(255,255,255,0.06)" }
            },
            y: {
              min: 0,
              max: 1,
              title: {
                display: true,
                text: "Normalized Score (s·µ¢)",
                color: "#a9b4d6",
                font: { size: 11 }
              },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            }
          }
        }
      });
    }
  }

  // ---------- SLO Method Params Config ----------
  const sloMethodConfig = {
    prefix: "slo",
    stateObj: state,
    containerEl: el.methodParams,
    methodSelectEl: el.method,
    recomputeFn: () => recompute(),
    renderChartFn: () => renderSloChart(),
    descriptions: {
      exponential: "Lower = harsher penalty",
      linear: "Score reaches zero at this negative EB%",
      logarithmic: "Score reaches zero at this negative EB%"
    }
  };
  
  function renderSloMethodParams() {
    renderMethodParams(sloMethodConfig);
  }

  // ---------- Compute ----------
  function recompute() {
    // Keep tier weights synced
    state.tierWeights.p0 = Number(el.wP0.value);
    state.tierWeights.p1 = Number(el.wP1.value);
    state.tierWeights.p2 = Number(el.wP2.value);
    state.method = el.method.value || "exponential";

    // Ensure params exist (handle old saved state)
    if (!state.params) {
      state.params = {
        exponential: { decay: 0.85 },
        linear: { threshold: 10 },
        inverse: { k: 1.0 },
        logarithmic: { maxExpected: 20 },
        sigmoid: { midpoint: 5, steepness: 1.0 },
        bucket: { buckets: [[0, 1.0], [1, 0.8], [3, 0.5], [6, 0.2], [11, 0.0]] }
      };
    }

    const method = state.method;
    const params = state.params[method];
    const normMethod = normMethods[method];

    // Build per-SLO values with penalty-based normalization
    const items = state.slos.map(slo => {
      const ebPct = Number(slo.ebPct);
      // NEW: EB% >= 0 gives full score, negative EB% applies penalty
      const negativeAmount = Math.max(0, -ebPct);
      const s = ebPct >= 0 ? 1.0 : normMethod.calc(negativeAmount, params);
      const w = Math.max(0, Number(weightForSlo(slo))); // don't allow negative weight
      const ws = w * s;
      return { ...slo, ebPct, negativeAmount, s, w, ws };
    });

    // Weighted average
    const denom = items.reduce((acc, it) => acc + it.w, 0);
    const numer = items.reduce((acc, it) => acc + it.ws, 0);
    const S = (denom > 0 && items.length > 0) ? (numer / denom) : 0;
    
    const pointBudget = Math.max(0, Number(el.pointBudget.value) || 0);
    state.pointBudget = pointBudget;
    const points = pointBudget * clamp(S, 0, 1);

    // Render results
    el.scoreS.textContent = fmt(S, 4);
    el.points.textContent = fmt2(points);
    el.pointsMax.textContent = pointBudget;
    el.scoreBar.style.width = (S * 100).toFixed(1) + "%";

    // Status note
    el.pointsNote.textContent = `Computed from ${items.length} SLO(s)`;

    // Render aggregate visualization
    renderAggregateViz(items, denom, numer, S);

    // Render chart and method params
    renderSloChart();
    
    // Formula box
    const modeDesc = `Tier weights (p0=${state.tierWeights.p0}, p1=${state.tierWeights.p1}, p2=${state.tierWeights.p2})`;
    const methodInfo = normMethods[method];
    const sloList = items.map(it => 
      `    ${it.name}: EB%=${it.ebPct}, ${it.ebPct >= 0 ? 'no penalty' : `penalty on ${Math.abs(it.ebPct)}%`} ‚Üí s = ${fmt(it.s, 4)}`
    ).join("\n") || "    (no SLOs)";

    el.formulaBox.textContent =
`DEFINITIONS
  w·µ¢    = weight for an individual SLO (determined by tier: ${modeDesc})
  s·µ¢    = normalized score for an individual SLO
          - If EB% >= 0: s·µ¢ = 1.0 (meeting SLO, full points)
          - If EB% < 0: apply penalty using ${methodInfo.name}
  Penalty formula: ${methodInfo.formula(params)}
  S     = weighted average of all individual s·µ¢ values (0‚Äì1)
  Score = final scorecard value (budget √ó S)

CURRENT SLOs (${items.length} total)
${sloList}

CALCULATION
  Weighted average:
    S = Œ£(w·µ¢ √ó s·µ¢) / Œ£(w·µ¢)
    S = ${fmt(numer,4)} / ${fmt(denom,4)} = ${fmt(S,4)}

  Final score:
    score = ${pointBudget} √ó ${fmt(S,4)} = ${fmt2(points)}
`;
    
    // Update sidebar
    currentScores.slo = points;
    currentScores.sloMax = pointBudget;
    updateSidebar();
    
    // Persist state
    saveAllState();
  }

  // ---------- Events ----------
  el.pointBudget.addEventListener("input", recompute);
  el.wP0.addEventListener("input", recompute);
  el.wP1.addEventListener("input", recompute);
  el.wP2.addEventListener("input", recompute);
  setupMethodChangeHandler(sloMethodConfig);
  el.showAllMethods.addEventListener("change", () => {
    renderSloChart();
  });

  const sloNameInventory = [
    "API availability",
    "Checkout latency",
    "Login success rate",
    "Payment processing time",
    "Search response time",
    "Order completion rate",
    "Page load time",
    "Database query latency",
    "Cache hit rate",
    "Error rate",
    "Webhook delivery",
    "Email delivery rate",
    "File upload success",
    "Session creation time",
    "Report generation time",
    "Data sync latency",
    "Notification delivery",
    "Authentication latency",
    "Image processing time",
    "Video transcoding rate",
    "Batch job success rate",
    "Queue processing time",
    "CDN response time",
    "Mobile app crash rate",
    "Third-party API latency",
  ];

  function getRandomSloName() {
    const usedNames = new Set(state.slos.map(s => s.name));
    const available = sloNameInventory.filter(n => !usedNames.has(n));
    if (available.length === 0) {
      return `Custom SLO ${state.slos.length + 1}`;
    }
    return available[Math.floor(Math.random() * available.length)];
  }

  el.addSlo.addEventListener("click", () => {
    state.slos.push({
      name: getRandomSloName(),
      ebPct: Math.floor(Math.random() * 51) + 50, // Random 50-100
      tier: ["p0", "p1", "p2"][Math.floor(Math.random() * 3)]
    });
    renderTable();
    recompute();
  });

  function syncControlsFromState() {
    el.pointBudget.value = state.pointBudget;
    el.wP0.value = state.tierWeights.p0;
    el.wP1.value = state.tierWeights.p1;
    el.wP2.value = state.tierWeights.p2;
    el.method.value = state.method || "exponential";
  }

  // ---------- Init ----------
    syncControlsFromState();
    renderSloMethodParams();
    renderTable();
    recompute();

  // ==========================================================================
  // CONTAINER VULNS SECTION
  // ==========================================================================

  // ---------- Vuln State ----------
  let vulnState = {
    budget: sharedConfig.vuln.budget,
    weights: sharedConfig.vuln.weights,
    method: sharedConfig.vuln.method,
    params: sharedConfig.vuln.params,
    images: initialTeamData.images
  };
  window.vulnState = vulnState;  // Make accessible to calculateOpportunities

  // ---------- Vuln DOM ----------
  const vulnEl = {
    wCritical: document.getElementById("vulnWCritical"),
    wHigh: document.getElementById("vulnWHigh"),
    wMedium: document.getElementById("vulnWMedium"),
    wLow: document.getElementById("vulnWLow"),
    budget: document.getElementById("vulnBudget"),
    method: document.getElementById("vulnMethod"),
    methodParams: document.getElementById("vulnMethodParams"),
    chartCanvas: document.getElementById("vulnChart"),
    showAllMethods: document.getElementById("vulnShowAllMethods"),
    tbody: document.getElementById("vulnTbody"),
    addBtn: document.getElementById("addVuln"),
    scoreS: document.getElementById("vulnScoreS"),
    scoreBar: document.getElementById("vulnScoreBar"),
    score: document.getElementById("vulnScore"),
    scoreMax: document.getElementById("vulnScoreMax"),
    scoreNote: document.getElementById("vulnScoreNote"),
    aggTable: document.getElementById("vulnAggTable"),
    formulaBox: document.getElementById("vulnFormulaBox"),
  };

  // Chart instance
  let vulnChart = null;

  // ---------- Render Chart ----------
  function renderVulnChart() {
    const showAll = vulnEl.showAllMethods.checked;
    const currentMethod = vulnState.method;
    const maxCount = 25;
    
    // Generate x-axis labels (counts 0 to maxCount)
    const labels = Array.from({ length: maxCount + 1 }, (_, i) => i);
    
    // Generate datasets
    const datasets = [];
    
    if (showAll) {
      // Show all methods
      Object.entries(normMethods).forEach(([key, methodInfo]) => {
        const params = vulnState.params[key];
        const data = labels.map(count => methodInfo.calc(count, params));
        const isSelected = key === currentMethod;
        
        datasets.push({
          label: methodInfo.name,
          data: data,
          borderColor: methodColors[key].border,
          backgroundColor: isSelected ? methodColors[key].bg : "transparent",
          borderWidth: isSelected ? 3 : 1.5,
          pointRadius: 0,
          tension: key === "bucket" ? 0 : 0.3,
          stepped: key === "bucket" ? "before" : false,
          fill: isSelected,
          order: isSelected ? 0 : 1  // Selected on top
        });
      });
    } else {
      // Show only selected method
      const params = vulnState.params[currentMethod];
      const methodInfo = normMethods[currentMethod];
      const data = labels.map(count => methodInfo.calc(count, params));
      
      datasets.push({
        label: methodInfo.name,
        data: data,
        borderColor: methodColors[currentMethod].border,
        backgroundColor: methodColors[currentMethod].bg,
        borderWidth: 3,
        pointRadius: 0,
        tension: currentMethod === "bucket" ? 0 : 0.3,
        stepped: currentMethod === "bucket" ? "before" : false,
        fill: true
      });
    }
    
    // Create or update chart
    if (vulnChart) {
      vulnChart.data.labels = labels;
      vulnChart.data.datasets = datasets;
      vulnChart.update("none");  // No animation for snappy updates
    } else {
      vulnChart = new Chart(vulnEl.chartCanvas, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: "index"
          },
          plugins: {
            legend: {
              display: showAll,
              position: "bottom",
              labels: {
                color: "#a9b4d6",
                font: { size: 11 },
                boxWidth: 12,
                padding: 8
              }
            },
            tooltip: {
              backgroundColor: "rgba(17,25,53,0.95)",
              titleColor: "#e9eefc",
              bodyColor: "#a9b4d6",
              borderColor: "rgba(255,255,255,0.1)",
              borderWidth: 1,
              padding: 10,
              callbacks: {
                title: (items) => `Count: ${items[0].label}`,
                label: (item) => `${item.dataset.label}: ${item.parsed.y.toFixed(4)}`
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: "Vulnerability Count",
                color: "#a9b4d6",
                font: { size: 11 }
              },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            },
            y: {
              min: 0,
              max: 1,
              title: {
                display: true,
                text: "Normalized Score (s·µ¢)",
                color: "#a9b4d6",
                font: { size: 11 }
              },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            }
          }
        }
      });
    }
    
    // Update legend visibility when toggling show all
    vulnChart.options.plugins.legend.display = showAll;
    vulnChart.update("none");
  }

  // ---------- Vuln Method Params Config ----------
  const vulnMethodConfig = {
    prefix: "vuln",
    stateObj: vulnState,
    containerEl: vulnEl.methodParams,
    methodSelectEl: vulnEl.method,
    recomputeFn: () => recomputeVuln(),
    renderChartFn: () => renderVulnChart(),
    descriptions: {
      exponential: "Each vuln multiplies score by this"
    }
  };
  
  function renderVulnMethodParams() {
    renderMethodParams(vulnMethodConfig);
  }

  // ---------- Render Vuln Table ----------
  function renderVulnTable() {
    vulnEl.tbody.innerHTML = "";
    
    vulnState.images.forEach((img, idx) => {
      const tr = document.createElement("tr");
      tr.id = `vuln-row-${idx}`;  // Add unique ID for direct linking
      
      tr.innerHTML = `
        <td><input type="text" value="${escapeHtml(img.name)}" style="width: 120px;" data-idx="${idx}" data-field="name" /></td>
        <td><input type="number" value="${img.critical}" min="0" style="width: 60px;" data-idx="${idx}" data-field="critical" /></td>
        <td><input type="number" value="${img.high}" min="0" style="width: 60px;" data-idx="${idx}" data-field="high" /></td>
        <td><input type="number" value="${img.medium}" min="0" style="width: 60px;" data-idx="${idx}" data-field="medium" /></td>
        <td><input type="number" value="${img.low}" min="0" style="width: 60px;" data-idx="${idx}" data-field="low" /></td>
        <td><button class="btn danger" data-idx="${idx}">Remove</button></td>
      `;
      
      vulnEl.tbody.appendChild(tr);
    });
    
    // Add event listeners
    vulnEl.tbody.querySelectorAll("input").forEach(inp => {
      inp.addEventListener("input", () => {
        const idx = Number(inp.dataset.idx);
        const field = inp.dataset.field;
        if (field === "name") {
          vulnState.images[idx].name = inp.value;
        } else {
          vulnState.images[idx][field] = Number(inp.value) || 0;
        }
        recomputeVuln();
      });
    });
    
    vulnEl.tbody.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        const idx = Number(btn.dataset.idx);
        vulnState.images.splice(idx, 1);
        renderVulnTable();
        recomputeVuln();
      });
    });
  }

  // ---------- Compute Vuln Score ----------
  function computeVulnScore(method, params) {
    const weights = vulnState.weights;
    const calcFn = normMethods[method].calc;
    const severities = ["critical", "high", "medium", "low"];
    
    // Aggregate vulnerabilities by severity across ALL images
    const severityTotals = {};
    severities.forEach(sev => {
      severityTotals[sev] = vulnState.images.reduce((sum, img) => sum + (img[sev] || 0), 0);
    });
    
    // Normalize each severity's total count, then compute weighted average
    const items = severities.map(sev => {
      const count = severityTotals[sev];
      const w = weights[sev];
      const s = calcFn(count, params);
      return { name: sev.charAt(0).toUpperCase() + sev.slice(1), severity: sev, count, w, s, ws: w * s };
    });
    
    const denom = items.reduce((acc, it) => acc + it.w, 0);
    const numer = items.reduce((acc, it) => acc + it.ws, 0);
    const S = denom > 0 ? numer / denom : 0;
    
    return { items, denom, numer, S, severityTotals };
  }
  window.computeVulnScore = computeVulnScore;  // Make accessible to calculateOpportunities

  function recomputeVuln() {
    // Sync weights
    vulnState.weights.critical = Number(vulnEl.wCritical.value) || 4;
    vulnState.weights.high = Number(vulnEl.wHigh.value) || 2;
    vulnState.weights.medium = Number(vulnEl.wMedium.value) || 1;
    vulnState.weights.low = Number(vulnEl.wLow.value) || 0.5;
    
    vulnState.budget = Number(vulnEl.budget.value) || 20;
    vulnState.method = vulnEl.method.value;
    
    const method = vulnState.method;
    const params = vulnState.params[method];
    
    const { items, denom, numer, S } = computeVulnScore(method, params);
    const score = vulnState.budget * clamp(S, 0, 1);
    
    // Update display
    vulnEl.scoreS.textContent = fmt(S, 4);
    vulnEl.score.textContent = fmt2(score);
    vulnEl.scoreMax.textContent = vulnState.budget;
    vulnEl.scoreBar.style.width = (S * 100).toFixed(1) + "%";
    const totalVulns = vulnState.images.reduce((sum, img) => 
      sum + img.critical + img.high + img.medium + img.low, 0);
    vulnEl.scoreNote.textContent = `${totalVulns} vulns across ${vulnState.images.length} image(s)`;
    
    // Render aggregate table
    renderVulnAggTable(items, denom, numer, S);
    
    // Render chart
    renderVulnChart();
    
    // Render formula box
    renderVulnFormula(method, params, S, score);
    
    // Update sidebar
    currentScores.vulns = score;
    currentScores.vulnsMax = vulnState.budget;
    updateSidebar();
    
    // Persist state
    saveAllState();
  }

  function renderVulnAggTable(items, denom, numer, S) {
    const thead = vulnEl.aggTable.querySelector("thead");
    const tbody = vulnEl.aggTable.querySelector("tbody");
    const tfoot = vulnEl.aggTable.querySelector("tfoot");
    
    thead.innerHTML = "";
    tbody.innerHTML = "";
    tfoot.innerHTML = "";
    
    if (vulnState.images.length === 0) {
      tbody.innerHTML = `<tr><td colspan="5" class="muted">No images defined.</td></tr>`;
      return;
    }
    
    thead.innerHTML = `
      <tr>
        <th>Severity</th>
        <th class="right">Total Count</th>
        <th class="right">s·µ¢</th>
        <th class="right">w·µ¢</th>
        <th class="right">w·µ¢ ¬∑ s·µ¢</th>
      </tr>
    `;
    
    items.forEach(it => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(it.name)}</td>
        <td class="mono right">${it.count}</td>
        <td class="mono right">${fmt(it.s, 4)}</td>
        <td class="mono right">${fmt(it.w, 2)}</td>
        <td class="mono right">${fmt(it.ws, 4)}</td>
      `;
      tbody.appendChild(tr);
    });
    
    tfoot.innerHTML = `
      <tr>
        <td>Total</td>
        <td class="mono right muted">‚Äî</td>
        <td class="mono right muted">‚Äî</td>
        <td class="mono right">${fmt(denom, 2)}</td>
        <td class="mono right">${fmt(numer, 4)}</td>
      </tr>
      <tr>
        <td colspan="4" style="text-align: right; padding-right: 10px;">S = Œ£(w·µ¢¬∑s·µ¢) / Œ£(w·µ¢) =</td>
        <td class="mono right" style="font-size: 16px;">${fmt(S, 4)}</td>
      </tr>
    `;
  }

  function renderVulnFormula(method, params, S, score) {
    const methodInfo = normMethods[method];
    const weightsDesc = `Critical=${vulnState.weights.critical}, High=${vulnState.weights.high}, Medium=${vulnState.weights.medium}, Low=${vulnState.weights.low}`;
    
    // Get severity totals for display
    const severities = ["critical", "high", "medium", "low"];
    const totals = severities.map(sev => {
      const count = vulnState.images.reduce((sum, img) => sum + (img[sev] || 0), 0);
      return `${sev}: ${count}`;
    }).join(", ");
    
    vulnEl.formulaBox.textContent = 
`DEFINITIONS
  The subscript "i" refers to a severity level (Critical, High, Medium, Low).
  
  w·µ¢    = weight for severity i (${weightsDesc})
  s·µ¢    = normalized score for severity i (based on total count across all images)
  S     = weighted average of all severity scores (0‚Äì1)
  Score = final scorecard value (budget √ó S)

HOW IT WORKS
  1. Sum vulnerability counts by severity across ALL images
     Current totals: ${totals}
  
  2. Normalize each severity's total using: ${methodInfo.formula(params)}
  
  3. Compute weighted average: S = Œ£(w·µ¢¬∑s·µ¢) / Œ£(w·µ¢)

CALCULATION
  S = ${fmt(S, 4)}
  Score = ${vulnState.budget} √ó ${fmt(S, 4)} = ${fmt2(score)}
`;
  }

  // ---------- Vuln Events ----------
  setupMethodChangeHandler(vulnMethodConfig);
  
  vulnEl.wCritical.addEventListener("input", recomputeVuln);
  vulnEl.wHigh.addEventListener("input", recomputeVuln);
  vulnEl.wMedium.addEventListener("input", recomputeVuln);
  vulnEl.wLow.addEventListener("input", recomputeVuln);
  
  vulnEl.showAllMethods.addEventListener("change", renderVulnChart);
  vulnEl.budget.addEventListener("input", recomputeVuln);
  
  const imageNameInventory = [
    "api-server", "worker", "frontend", "backend", "gateway",
    "scheduler", "cache", "database", "auth-service", "payment-service",
    "notification-service", "analytics", "search", "cdn-origin", "proxy"
  ];
  
  vulnEl.addBtn.addEventListener("click", () => {
    const usedNames = new Set(vulnState.images.map(i => i.name));
    const available = imageNameInventory.filter(n => !usedNames.has(n));
    const name = available.length > 0 
      ? available[Math.floor(Math.random() * available.length)]
      : `image-${vulnState.images.length + 1}`;
    
    vulnState.images.push({
      name,
      critical: Math.floor(Math.random() * 3),
      high: Math.floor(Math.random() * 6),
      medium: Math.floor(Math.random() * 15),
      low: Math.floor(Math.random() * 40)
    });
    renderVulnTable();
    recomputeVuln();
  });

  // ---------- Vuln Init ----------
  function syncVulnControlsFromState() {
    vulnEl.budget.value = vulnState.budget;
    vulnEl.wCritical.value = vulnState.weights.critical;
    vulnEl.wHigh.value = vulnState.weights.high;
    vulnEl.wMedium.value = vulnState.weights.medium;
    vulnEl.wLow.value = vulnState.weights.low;
    vulnEl.method.value = vulnState.method;
  }
  
  syncVulnControlsFromState();
  renderVulnMethodParams();
  renderVulnTable();
  recomputeVuln();

  // ==========================================================================
  // BUG REPORTS SECTION
  // ==========================================================================

  let bugState = {
    budget: sharedConfig.bug.budget,
    weights: sharedConfig.bug.weights,
    method: sharedConfig.bug.method,
    params: sharedConfig.bug.params,
    tickets: initialTeamData.tickets
  };
  window.bugState = bugState;  // Make accessible to calculateOpportunities

  // ---------- Bug DOM ----------
  const bugEl = {
    wP0: document.getElementById("bugWP0"),
    wP1: document.getElementById("bugWP1"),
    wP2: document.getElementById("bugWP2"),
    budget: document.getElementById("bugBudget"),
    method: document.getElementById("bugMethod"),
    methodParams: document.getElementById("bugMethodParams"),
    chartCanvas: document.getElementById("bugChart"),
    showAllMethods: document.getElementById("bugShowAllMethods"),
    tbody: document.getElementById("bugTbody"),
    addBtn: document.getElementById("addBug"),
    scoreS: document.getElementById("bugScoreS"),
    scoreBar: document.getElementById("bugScoreBar"),
    score: document.getElementById("bugScore"),
    scoreMax: document.getElementById("bugScoreMax"),
    scoreNote: document.getElementById("bugScoreNote"),
    aggTable: document.getElementById("bugAggTable"),
    formulaBox: document.getElementById("bugFormulaBox"),
  };

  // Bug chart instance
  let bugChart = null;

  // ---------- Compute Bug Score ----------
  function computeBugScore(method, params) {
    const priorities = ["p0", "p1", "p2"];
    const calcFn = normMethods[method].calc;
    
    // Count tickets by priority
    const counts = { p0: 0, p1: 0, p2: 0 };
    bugState.tickets.forEach(ticket => {
      if (counts.hasOwnProperty(ticket.priority)) {
        counts[ticket.priority]++;
      }
    });
    
    const items = priorities.map(prio => {
      const count = counts[prio];
      const w = bugState.weights[prio] || 1;
      const s = calcFn(count, params);
      return { name: prio.toUpperCase(), prio, count, w, s, ws: w * s };
    });
    
    const denom = items.reduce((sum, it) => sum + it.w, 0);
    const numer = items.reduce((sum, it) => sum + it.ws, 0);
    const S = denom > 0 ? numer / denom : 1;
    
    return { items, denom, numer, S, counts };
  }
  window.computeBugScore = computeBugScore;  // Make accessible to calculateOpportunities

  function recomputeBug() {
    // Sync config state from inputs
    bugState.weights.p0 = Number(bugEl.wP0.value) || 4;
    bugState.weights.p1 = Number(bugEl.wP1.value) || 2;
    bugState.weights.p2 = Number(bugEl.wP2.value) || 1;
    bugState.budget = Number(bugEl.budget.value) || 20;
    bugState.method = bugEl.method.value;
    
    const method = bugState.method;
    const params = bugState.params[method];
    
    const { items, denom, numer, S, counts } = computeBugScore(method, params);
    const score = bugState.budget * clamp(S, 0, 1);
    const totalTickets = bugState.tickets.length;
    
    // Update KPIs
    bugEl.scoreS.textContent = fmt(S, 4);
    bugEl.score.textContent = fmt2(score);
    bugEl.scoreMax.textContent = bugState.budget;
    bugEl.scoreBar.style.width = (S * 100).toFixed(1) + "%";
    
    // Status note
    let note = "";
    if (S >= 0.9) note = "Excellent ‚Äì very few bugs";
    else if (S >= 0.7) note = "Good ‚Äì manageable bug count";
    else if (S >= 0.5) note = "Fair ‚Äì bugs accumulating";
    else if (S >= 0.3) note = "Poor ‚Äì significant bug backlog";
    else note = "Critical ‚Äì overwhelming bug count";
    bugEl.scoreNote.textContent = `${totalTickets} ticket(s): ${note}`;
    
    // Render aggregate table
    renderBugAggTable(items, denom, numer, S);
    
    // Render chart
    renderBugChart();
    
    // Render formula
    renderBugFormula(items, denom, numer, S, score);
    
    // Update sidebar
    currentScores.bugs = score;
    currentScores.bugsMax = bugState.budget;
    updateSidebar();
    
    // Persist state
    saveAllState();
  }

  function renderBugAggTable(items, denom, numer, S) {
    const thead = bugEl.aggTable.querySelector("thead");
    const tbody = bugEl.aggTable.querySelector("tbody");
    const tfoot = bugEl.aggTable.querySelector("tfoot");
    
    thead.innerHTML = "";
    tbody.innerHTML = "";
    tfoot.innerHTML = "";
    
    if (items.length === 0) {
      tbody.innerHTML = `<tr><td colspan="5" class="muted">No data.</td></tr>`;
      return;
    }
    
    thead.innerHTML = `
      <tr>
        <th>Priority</th>
        <th class="right">Count</th>
        <th class="right">s·µ¢</th>
        <th class="right">w·µ¢</th>
        <th class="right">w·µ¢ ¬∑ s·µ¢</th>
      </tr>
    `;
    
    items.forEach(it => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(it.name)}</td>
        <td class="mono right">${it.count}</td>
        <td class="mono right">${fmt(it.s, 4)}</td>
        <td class="mono right">${fmt(it.w, 2)}</td>
        <td class="mono right">${fmt(it.ws, 4)}</td>
      `;
      tbody.appendChild(tr);
    });
    
    tfoot.innerHTML = `
      <tr>
        <td>Total</td>
        <td class="mono right muted">‚Äî</td>
        <td class="mono right muted">‚Äî</td>
        <td class="mono right">${fmt(denom, 2)}</td>
        <td class="mono right">${fmt(numer, 4)}</td>
      </tr>
      <tr>
        <td colspan="4" style="text-align: right; padding-right: 10px;">S = Œ£(w·µ¢¬∑s·µ¢) / Œ£(w·µ¢) =</td>
        <td class="mono right" style="font-size: 16px;">${fmt(S, 4)}</td>
      </tr>
    `;
  }

  function renderBugFormula(items, denom, numer, S, score) {
    const method = bugState.method;
    const params = bugState.params[method];
    const methodInfo = normMethods[method];
    const weightsDesc = `P0=${bugState.weights.p0}, P1=${bugState.weights.p1}, P2=${bugState.weights.p2}`;
    const countsDesc = items.map(it => `${it.name}: ${it.count}`).join(", ");
    const ticketList = bugState.tickets.map(t => `    ${t.name} (${t.priority.toUpperCase()})`).join("\n") || "    (no tickets)";
    
    bugEl.formulaBox.textContent =
`DEFINITIONS
  w·µ¢    = weight for priority level (${weightsDesc})
  s·µ¢    = normalized score using ${methodInfo.name}
  Formula: ${methodInfo.formula(params)}
  S     = weighted average of all s·µ¢ values (0‚Äì1)
  Score = final scorecard value (budget √ó S)

CURRENT TICKETS (${bugState.tickets.length} total)
${ticketList}

AGGREGATED COUNTS
  ${countsDesc}

CALCULATION
  For each priority:
${items.map(it => `    ${it.name}: count=${it.count} ‚Üí s = ${fmt(it.s, 4)}`).join("\n")}

  Weighted average:
    S = Œ£(w·µ¢ √ó s·µ¢) / Œ£(w·µ¢)
    S = ${fmt(numer, 4)} / ${fmt(denom, 4)} = ${fmt(S, 4)}

  Final score:
    score = ${bugState.budget} √ó ${fmt(S, 4)} = ${fmt2(score)}
`;
  }

  function renderBugChart() {
    const showAll = bugEl.showAllMethods.checked;
    const currentMethod = bugState.method;
    const maxCount = 25;
    
    const labels = Array.from({ length: maxCount + 1 }, (_, i) => i);
    const datasets = [];
    
    if (showAll) {
      Object.entries(normMethods).forEach(([key, methodInfo]) => {
        const params = bugState.params[key];
        const data = labels.map(count => methodInfo.calc(count, params));
        const isSelected = key === currentMethod;
        
        datasets.push({
          label: methodInfo.name,
          data: data,
          borderColor: methodColors[key].border,
          backgroundColor: isSelected ? methodColors[key].bg : "transparent",
          borderWidth: isSelected ? 3 : 1.5,
          pointRadius: 0,
          tension: key === "bucket" ? 0 : 0.3,
          stepped: key === "bucket" ? "before" : false,
          fill: isSelected,
          order: isSelected ? 0 : 1
        });
      });
    } else {
      const params = bugState.params[currentMethod];
      const methodInfo = normMethods[currentMethod];
      const data = labels.map(count => methodInfo.calc(count, params));
      
      datasets.push({
        label: methodInfo.name,
        data: data,
        borderColor: methodColors[currentMethod].border,
        backgroundColor: methodColors[currentMethod].bg,
        borderWidth: 3,
        pointRadius: 0,
        tension: currentMethod === "bucket" ? 0 : 0.3,
        stepped: currentMethod === "bucket" ? "before" : false,
        fill: true
      });
    }
    
    if (bugChart) {
      bugChart.data.labels = labels;
      bugChart.data.datasets = datasets;
      bugChart.options.plugins.legend.display = showAll;
      bugChart.update("none");
    } else {
      bugChart = new Chart(bugEl.chartCanvas, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { intersect: false, mode: "index" },
          plugins: {
            legend: {
              display: showAll,
              position: "bottom",
              labels: { color: "#a9b4d6", font: { size: 11 }, boxWidth: 12, padding: 8 }
            }
          },
          scales: {
            x: {
              title: { display: true, text: "Bug Count", color: "#a9b4d6", font: { size: 11 } },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            },
            y: {
              min: 0,
              max: 1,
              title: { display: true, text: "Normalized Score (s·µ¢)", color: "#a9b4d6", font: { size: 11 } },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            }
          }
        }
      });
    }
  }

  // ---------- Render Bug Method Params ----------
  function renderBugMethodParams() {
    const method = bugState.method;
    const params = bugState.params[method];
    const methodInfo = normMethods[method];
    
    let html = "";
    
    if (method === "exponential") {
      html = `
        <div class="param-row">
          <span class="param-label">Decay rate:</span>
          <input type="number" id="bugParamDecay" step="0.05" min="0.1" max="0.99" value="${params.decay}" style="width: 80px;" />
          <span class="muted small">Each bug multiplies score by this</span>
        </div>
      `;
    } else if (method === "linear") {
      html = `
        <div class="param-row">
          <span class="param-label">Threshold:</span>
          <input type="number" id="bugParamThreshold" step="1" min="1" value="${params.threshold}" style="width: 80px;" />
          <span class="muted small">Count at which score = 0</span>
        </div>
      `;
    } else if (method === "inverse") {
      html = `
        <div class="param-row">
          <span class="param-label">Steepness (k):</span>
          <input type="number" id="bugParamK" step="0.1" min="0.1" value="${params.k}" style="width: 80px;" />
          <span class="muted small">Higher = faster drop</span>
        </div>
      `;
    } else if (method === "logarithmic") {
      html = `
        <div class="param-row">
          <span class="param-label">Max expected:</span>
          <input type="number" id="bugParamMax" step="1" min="1" value="${params.maxExpected}" style="width: 80px;" />
          <span class="muted small">Count at which score = 0</span>
        </div>
      `;
    } else if (method === "sigmoid") {
      html = `
        <div class="param-row">
          <span class="param-label">Midpoint:</span>
          <input type="number" id="bugParamMidpoint" step="1" min="1" value="${params.midpoint}" style="width: 80px;" />
          <span class="muted small">Count where score = 0.5</span>
        </div>
        <div class="param-row">
          <span class="param-label">Steepness:</span>
          <input type="number" id="bugParamSteepness" step="0.1" min="0.1" value="${params.steepness}" style="width: 80px;" />
          <span class="muted small">Higher = sharper transition</span>
        </div>
      `;
    } else if (method === "bucket") {
      html = `
        <div class="param-row">
          <span class="muted small">Bucket definitions (count threshold ‚Üí score):</span>
        </div>
        <div class="param-row" style="flex-wrap: wrap; gap: 6px;">
          ${params.buckets.map(([t, s]) => `
            <span class="mono" style="background: rgba(255,255,255,.1); padding: 4px 8px; border-radius: 6px;">
              ${t}+ ‚Üí ${fmt2(s)}
            </span>
          `).join("")}
        </div>
      `;
    }
    
    html += `
      <div class="formula-display" id="bugParamFormula">Formula: ${methodInfo.formula(params)}</div>
      <div class="example-display" id="bugParamExample">Example: ${methodInfo.examples(params)}</div>
    `;
    
    bugEl.methodParams.innerHTML = html;
    attachBugParamListeners();
  }

  function updateBugFormulaDisplay() {
    const method = bugState.method;
    const params = bugState.params[method];
    const methodInfo = normMethods[method];
    
    const formulaEl = document.getElementById("bugParamFormula");
    const exampleEl = document.getElementById("bugParamExample");
    
    if (formulaEl) formulaEl.textContent = `Formula: ${methodInfo.formula(params)}`;
    if (exampleEl) exampleEl.textContent = `Example: ${methodInfo.examples(params)}`;
  }

  function attachBugParamListeners() {
    const method = bugState.method;
    
    if (method === "exponential") {
      const inp = document.getElementById("bugParamDecay");
      if (inp) inp.addEventListener("input", () => {
        bugState.params.exponential.decay = Number(inp.value) || 0.85;
        updateBugFormulaDisplay();
        recomputeBug();
      });
    } else if (method === "linear") {
      const inp = document.getElementById("bugParamThreshold");
      if (inp) inp.addEventListener("input", () => {
        bugState.params.linear.threshold = Number(inp.value) || 10;
        updateBugFormulaDisplay();
        recomputeBug();
      });
    } else if (method === "inverse") {
      const inp = document.getElementById("bugParamK");
      if (inp) inp.addEventListener("input", () => {
        bugState.params.inverse.k = Number(inp.value) || 1;
        updateBugFormulaDisplay();
        recomputeBug();
      });
    } else if (method === "logarithmic") {
      const inp = document.getElementById("bugParamMax");
      if (inp) inp.addEventListener("input", () => {
        bugState.params.logarithmic.maxExpected = Number(inp.value) || 20;
        updateBugFormulaDisplay();
        recomputeBug();
      });
    } else if (method === "sigmoid") {
      const mid = document.getElementById("bugParamMidpoint");
      const steep = document.getElementById("bugParamSteepness");
      if (mid) mid.addEventListener("input", () => {
        bugState.params.sigmoid.midpoint = Number(mid.value) || 5;
        updateBugFormulaDisplay();
        recomputeBug();
      });
      if (steep) steep.addEventListener("input", () => {
        bugState.params.sigmoid.steepness = Number(steep.value) || 1;
        updateBugFormulaDisplay();
        recomputeBug();
      });
    }
  }

  // ---------- Render Bug Table ----------
  function renderBugTable() {
    bugEl.tbody.innerHTML = "";
    
    bugState.tickets.forEach((ticket, idx) => {
      const tr = document.createElement("tr");
      tr.id = `bug-row-${idx}`;  // Add unique ID for direct linking
      
      tr.innerHTML = `
        <td><input type="text" value="${escapeHtml(ticket.name)}" style="width: 140px;" data-idx="${idx}" data-field="name" /></td>
        <td>
          <select data-idx="${idx}" data-field="priority" style="width: 70px;">
            <option value="p0" ${ticket.priority === "p0" ? "selected" : ""}>P0</option>
            <option value="p1" ${ticket.priority === "p1" ? "selected" : ""}>P1</option>
            <option value="p2" ${ticket.priority === "p2" ? "selected" : ""}>P2</option>
          </select>
        </td>
        <td><button class="btn danger" data-idx="${idx}">Remove</button></td>
      `;
      
      bugEl.tbody.appendChild(tr);
    });
    
    // Add event listeners
    bugEl.tbody.querySelectorAll("input, select").forEach(inp => {
      inp.addEventListener("input", () => {
        const idx = Number(inp.dataset.idx);
        const field = inp.dataset.field;
        bugState.tickets[idx][field] = inp.value;
        recomputeBug();
      });
      inp.addEventListener("change", () => {
        const idx = Number(inp.dataset.idx);
        const field = inp.dataset.field;
        bugState.tickets[idx][field] = inp.value;
        recomputeBug();
      });
    });
    
    bugEl.tbody.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        const idx = Number(btn.dataset.idx);
        bugState.tickets.splice(idx, 1);
        renderBugTable();
        recomputeBug();
      });
    });
  }

  // ---------- Bug Events ----------
  bugEl.wP0.addEventListener("input", recomputeBug);
  bugEl.wP1.addEventListener("input", recomputeBug);
  bugEl.wP2.addEventListener("input", recomputeBug);
  bugEl.budget.addEventListener("input", recomputeBug);
  bugEl.method.addEventListener("change", () => {
    bugState.method = bugEl.method.value;
    renderBugMethodParams();
    recomputeBug();
  });
  bugEl.showAllMethods.addEventListener("change", renderBugChart);

  const ticketNameInventory = [
    "BUG-1234", "BUG-2345", "BUG-3456", "BUG-4567", "BUG-5678",
    "BUG-6789", "BUG-7890", "BUG-8901", "BUG-9012", "BUG-0123",
    "BUG-1357", "BUG-2468", "BUG-3579", "BUG-4680", "BUG-5791",
    "BUG-6802", "BUG-7913", "BUG-8024", "BUG-9135", "BUG-0246"
  ];

  bugEl.addBtn.addEventListener("click", () => {
    const usedNames = new Set(bugState.tickets.map(t => t.name));
    const available = ticketNameInventory.filter(n => !usedNames.has(n));
    const name = available.length > 0 
      ? available[Math.floor(Math.random() * available.length)]
      : `BUG-${Date.now().toString(36).toUpperCase()}`;
    
    const priorities = ["p0", "p1", "p2"];
    // Weight towards P2 for realism
    const weights = [0.1, 0.3, 0.6];
    const rand = Math.random();
    let priority = "p2";
    let cumulative = 0;
    for (let i = 0; i < priorities.length; i++) {
      cumulative += weights[i];
      if (rand < cumulative) {
        priority = priorities[i];
        break;
      }
    }
    
    bugState.tickets.push({ name, priority });
    renderBugTable();
    recomputeBug();
  });

  // ---------- Bug Init ----------
  function syncBugControlsFromState() {
    bugEl.budget.value = bugState.budget;
    bugEl.method.value = bugState.method;
    bugEl.wP0.value = bugState.weights.p0;
    bugEl.wP1.value = bugState.weights.p1;
    bugEl.wP2.value = bugState.weights.p2;
  }
  
  syncBugControlsFromState();
  renderBugMethodParams();
  renderBugTable();
  recomputeBug();

  // ==========================================================================
  // POSTMORTEMS SECTION
  // ==========================================================================

  let pmState = {
    budget: sharedConfig.pm.budget,
    severityWeights: sharedConfig.pm.severityWeights,
    typeWeights: sharedConfig.pm.typeWeights,
    method: sharedConfig.pm.method,
    params: sharedConfig.pm.params,
    problems: initialTeamData.problems
  };
  window.pmState = pmState;  // Make accessible to calculateOpportunities

  // ---------- PM DOM ----------
  const pmEl = {
    wSev1: document.getElementById("pmWSev1"),
    wSev2: document.getElementById("pmWSev2"),
    wSev3: document.getElementById("pmWSev3"),
    wSev4: document.getElementById("pmWSev4"),
    wPostmortem: document.getElementById("pmWPostmortem"),
    wActions: document.getElementById("pmWActions"),
    wMetadata: document.getElementById("pmWMetadata"),
    budget: document.getElementById("pmBudget"),
    method: document.getElementById("pmMethod"),
    methodParams: document.getElementById("pmMethodParams"),
    chartCanvas: document.getElementById("pmChart"),
    showAllMethods: document.getElementById("pmShowAllMethods"),
    tbody: document.getElementById("pmTbody"),
    addBtn: document.getElementById("addPm"),
    scoreS: document.getElementById("pmScoreS"),
    scoreBar: document.getElementById("pmScoreBar"),
    score: document.getElementById("pmScore"),
    scoreMax: document.getElementById("pmScoreMax"),
    scoreNote: document.getElementById("pmScoreNote"),
    aggTable: document.getElementById("pmAggTable"),
    formulaBox: document.getElementById("pmFormulaBox"),
  };

  // PM chart instance
  let pmChart = null;

  // ---------- Compute PM Score ----------
  function computePmScore(method, params) {
    const severityWeights = pmState.severityWeights;
    const typeWeights = pmState.typeWeights;
    const calcFn = normMethods[method].calc;
    const problemTypes = ["metadata", "actions", "postmortem"];
    
    // Aggregate problems by type, weighted by severity
    const weightedTotals = { metadata: 0, actions: 0, postmortem: 0 };
    const rawCounts = { metadata: 0, actions: 0, postmortem: 0 };
    
    pmState.problems.forEach(problem => {
      const type = problem.problemType;
      if (weightedTotals.hasOwnProperty(type)) {
        const sevWeight = severityWeights[problem.severity] || 1;
        weightedTotals[type] += sevWeight;
        rawCounts[type]++;
      }
    });
    
    // Normalize each type's weighted total using selected method
    const items = problemTypes.map(type => {
      const weightedCount = weightedTotals[type];
      const rawCount = rawCounts[type];
      const w = typeWeights[type];
      const s = calcFn(weightedCount, params);
      return { 
        name: type === "metadata" ? "Missing metadata" : 
              type === "actions" ? "Incomplete actions" : 
              "Incomplete postmortem",
        type, 
        rawCount,
        weightedCount, 
        w, 
        s, 
        ws: w * s 
      };
    });
    
    const denom = items.reduce((sum, it) => sum + it.w, 0);
    const numer = items.reduce((sum, it) => sum + it.ws, 0);
    const S = denom > 0 ? numer / denom : 1;
    
    return { items, denom, numer, S, weightedTotals, rawCounts };
  }
  window.computePmScore = computePmScore;  // Make accessible to calculateOpportunities

  function recomputePm() {
    // Sync state from inputs
    pmState.severityWeights.sev1 = Number(pmEl.wSev1.value) || 4;
    pmState.severityWeights.sev2 = Number(pmEl.wSev2.value) || 2;
    pmState.severityWeights.sev3 = Number(pmEl.wSev3.value) || 1;
    pmState.severityWeights.sev4 = Number(pmEl.wSev4.value) || 0.5;
    pmState.typeWeights.postmortem = Number(pmEl.wPostmortem.value) || 3;
    pmState.typeWeights.actions = Number(pmEl.wActions.value) || 2;
    pmState.typeWeights.metadata = Number(pmEl.wMetadata.value) || 1;
    pmState.budget = Number(pmEl.budget.value) || 20;
    pmState.method = pmEl.method.value;
    
    const method = pmState.method;
    const params = pmState.params[method];
    
    const { items, denom, numer, S } = computePmScore(method, params);
    const score = pmState.budget * clamp(S, 0, 1);
    
    // Update KPIs
    pmEl.scoreS.textContent = fmt(S, 4);
    pmEl.score.textContent = fmt2(score);
    pmEl.scoreMax.textContent = pmState.budget;
    pmEl.scoreBar.style.width = (S * 100).toFixed(1) + "%";
    
    // Status note
    const totalProblems = pmState.problems.length;
    const uniqueIncidents = new Set(pmState.problems.map(p => p.incident)).size;
    pmEl.scoreNote.textContent = `${totalProblems} problem(s) across ${uniqueIncidents} incident(s)`;
    
    // Render aggregate table
    renderPmAggTable(items, denom, numer, S);
    
    // Render chart
    renderPmChart();
    
    // Render formula
    renderPmFormula(items, denom, numer, S, score);
    
    // Update sidebar
    currentScores.pm = score;
    currentScores.pmMax = pmState.budget;
    updateSidebar();
    
    // Persist state
    saveAllState();
  }

  function renderPmAggTable(items, denom, numer, S) {
    const thead = pmEl.aggTable.querySelector("thead");
    const tbody = pmEl.aggTable.querySelector("tbody");
    const tfoot = pmEl.aggTable.querySelector("tfoot");
    
    thead.innerHTML = "";
    tbody.innerHTML = "";
    tfoot.innerHTML = "";
    
    if (pmState.problems.length === 0) {
      tbody.innerHTML = `<tr><td colspan="6" class="muted">No problems defined.</td></tr>`;
      return;
    }
    
    thead.innerHTML = `
      <tr>
        <th>Problem Type</th>
        <th class="right">Count</th>
        <th class="right">Weighted</th>
        <th class="right">s·µ¢</th>
        <th class="right">w·µ¢</th>
        <th class="right">w·µ¢ ¬∑ s·µ¢</th>
      </tr>
    `;
    
    items.forEach(it => {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${escapeHtml(it.name)}</td>
        <td class="mono right">${it.rawCount}</td>
        <td class="mono right">${fmt(it.weightedCount, 2)}</td>
        <td class="mono right">${fmt(it.s, 4)}</td>
        <td class="mono right">${fmt(it.w, 2)}</td>
        <td class="mono right">${fmt(it.ws, 4)}</td>
      `;
      tbody.appendChild(tr);
    });
    
    tfoot.innerHTML = `
      <tr>
        <td>Total</td>
        <td class="mono right muted">‚Äî</td>
        <td class="mono right muted">‚Äî</td>
        <td class="mono right muted">‚Äî</td>
        <td class="mono right">${fmt(denom, 2)}</td>
        <td class="mono right">${fmt(numer, 4)}</td>
      </tr>
      <tr>
        <td colspan="5" style="text-align: right; padding-right: 10px;">S = Œ£(w·µ¢¬∑s·µ¢) / Œ£(w·µ¢) =</td>
        <td class="mono right" style="font-size: 16px;">${fmt(S, 4)}</td>
      </tr>
    `;
  }

  function renderPmFormula(items, denom, numer, S, score) {
    const method = pmState.method;
    const params = pmState.params[method];
    const methodInfo = normMethods[method];
    const sevWeightsDesc = `Sev1=${pmState.severityWeights.sev1}, Sev2=${pmState.severityWeights.sev2}, Sev3=${pmState.severityWeights.sev3}, Sev4=${pmState.severityWeights.sev4}`;
    const typeWeightsDesc = `Postmortem=${pmState.typeWeights.postmortem}, Actions=${pmState.typeWeights.actions}, Metadata=${pmState.typeWeights.metadata}`;
    
    // Build problem breakdown
    const problemBreakdown = pmState.problems.map(p => {
      const sevWeight = pmState.severityWeights[p.severity];
      const typeLabel = p.problemType === "metadata" ? "metadata" : 
                        p.problemType === "actions" ? "actions" : "postmortem";
      return `    ${p.incident} (${p.severity.toUpperCase()}, w=${sevWeight}): ${typeLabel} - "${p.description}"`;
    }).join("\n") || "    (no problems)";
    
    pmEl.formulaBox.textContent = 
`DEFINITIONS
  Severity weights: ${sevWeightsDesc}
  Problem type weights: ${typeWeightsDesc}
  Normalization: ${methodInfo.name}
  Formula: ${methodInfo.formula(params)}
  
  w·µ¢    = weight for problem type i
  s·µ¢    = normalized score for type i
  S     = weighted average of all type scores (0‚Äì1)
  Score = final scorecard value (budget √ó S)

CURRENT PROBLEMS (${pmState.problems.length} total)
${problemBreakdown}

AGGREGATION BY TYPE
  Each problem contributes its severity weight to its type's weighted count.
  
  Weighted totals by type:
${items.map(it => `     ${it.name}: ${it.rawCount} problems ‚Üí weighted ${fmt(it.weightedCount, 2)}`).join("\n")}
  
CALCULATION
  Normalize each type:
${items.map(it => `     ${it.name}: weighted=${fmt(it.weightedCount, 2)} ‚Üí s = ${fmt(it.s, 4)}`).join("\n")}
  
  Weighted average:
     S = Œ£(w·µ¢ √ó s·µ¢) / Œ£(w·µ¢)
     S = ${fmt(numer, 4)} / ${fmt(denom, 4)} = ${fmt(S, 4)}
  
  Final score:
     score = ${pmState.budget} √ó ${fmt(S, 4)} = ${fmt2(score)}
`;
  }

  // ---------- Render PM Chart ----------
  function renderPmChart() {
    const showAll = pmEl.showAllMethods.checked;
    const currentMethod = pmState.method;
    const maxCount = 25;
    
    const labels = Array.from({ length: maxCount + 1 }, (_, i) => i);
    const datasets = [];
    
    if (showAll) {
      Object.entries(normMethods).forEach(([key, methodInfo]) => {
        const params = pmState.params[key];
        const data = labels.map(count => methodInfo.calc(count, params));
        const isSelected = key === currentMethod;
        
        datasets.push({
          label: methodInfo.name,
          data: data,
          borderColor: methodColors[key].border,
          backgroundColor: isSelected ? methodColors[key].bg : "transparent",
          borderWidth: isSelected ? 3 : 1.5,
          pointRadius: 0,
          tension: key === "bucket" ? 0 : 0.3,
          stepped: key === "bucket" ? "before" : false,
          fill: isSelected,
          order: isSelected ? 0 : 1
        });
      });
    } else {
      const params = pmState.params[currentMethod];
      const methodInfo = normMethods[currentMethod];
      const data = labels.map(count => methodInfo.calc(count, params));
      
      datasets.push({
        label: methodInfo.name,
        data: data,
        borderColor: methodColors[currentMethod].border,
        backgroundColor: methodColors[currentMethod].bg,
        borderWidth: 3,
        pointRadius: 0,
        tension: currentMethod === "bucket" ? 0 : 0.3,
        stepped: currentMethod === "bucket" ? "before" : false,
        fill: true
      });
    }
    
    if (pmChart) {
      pmChart.data.labels = labels;
      pmChart.data.datasets = datasets;
      pmChart.options.plugins.legend.display = showAll;
      pmChart.update("none");
    } else {
      pmChart = new Chart(pmEl.chartCanvas, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { intersect: false, mode: "index" },
          plugins: {
            legend: {
              display: showAll,
              position: "bottom",
              labels: { color: "#a9b4d6", font: { size: 11 }, boxWidth: 12, padding: 8 }
            }
          },
          scales: {
            x: {
              title: { display: true, text: "Weighted Problem Count", color: "#a9b4d6", font: { size: 11 } },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            },
            y: {
              min: 0,
              max: 1,
              title: { display: true, text: "Normalized Score (s·µ¢)", color: "#a9b4d6", font: { size: 11 } },
              ticks: { color: "#a9b4d6", font: { size: 10 } },
              grid: { color: "rgba(255,255,255,0.06)" }
            }
          }
        }
      });
    }
  }

  // ---------- Render PM Method Params ----------
  function renderPmMethodParams() {
    const method = pmState.method;
    const params = pmState.params[method];
    const methodInfo = normMethods[method];
    
    let html = "";
    
    if (method === "exponential") {
      html = `
        <div class="param-row">
          <span class="param-label">Decay rate:</span>
          <input type="number" id="pmParamDecay" step="0.05" min="0.1" max="0.99" value="${params.decay}" style="width: 80px;" />
          <span class="muted small">Each weighted unit multiplies score by this</span>
        </div>
      `;
    } else if (method === "linear") {
      html = `
        <div class="param-row">
          <span class="param-label">Threshold:</span>
          <input type="number" id="pmParamThreshold" step="1" min="1" value="${params.threshold}" style="width: 80px;" />
          <span class="muted small">Weighted count at which score = 0</span>
        </div>
      `;
    } else if (method === "inverse") {
      html = `
        <div class="param-row">
          <span class="param-label">Steepness (k):</span>
          <input type="number" id="pmParamK" step="0.1" min="0.1" value="${params.k}" style="width: 80px;" />
          <span class="muted small">Higher = faster drop</span>
        </div>
      `;
    } else if (method === "logarithmic") {
      html = `
        <div class="param-row">
          <span class="param-label">Max expected:</span>
          <input type="number" id="pmParamMax" step="1" min="1" value="${params.maxExpected}" style="width: 80px;" />
          <span class="muted small">Weighted count at which score = 0</span>
        </div>
      `;
    } else if (method === "sigmoid") {
      html = `
        <div class="param-row">
          <span class="param-label">Midpoint:</span>
          <input type="number" id="pmParamMidpoint" step="1" min="1" value="${params.midpoint}" style="width: 80px;" />
          <span class="muted small">Count where score = 0.5</span>
        </div>
        <div class="param-row">
          <span class="param-label">Steepness:</span>
          <input type="number" id="pmParamSteepness" step="0.1" min="0.1" value="${params.steepness}" style="width: 80px;" />
          <span class="muted small">Higher = sharper transition</span>
        </div>
      `;
    } else if (method === "bucket") {
      html = `
        <div class="param-row">
          <span class="muted small">Bucket definitions (weighted count threshold ‚Üí score):</span>
        </div>
        <div class="param-row" style="flex-wrap: wrap; gap: 6px;">
          ${params.buckets.map(([t, s]) => `
            <span class="mono" style="background: rgba(255,255,255,.1); padding: 4px 8px; border-radius: 6px;">
              ${t}+ ‚Üí ${fmt2(s)}
            </span>
          `).join("")}
        </div>
      `;
    }
    
    html += `
      <div class="formula-display" id="pmParamFormula">Formula: ${methodInfo.formula(params)}</div>
      <div class="example-display" id="pmParamExample">Example: ${methodInfo.examples(params)}</div>
    `;
    
    pmEl.methodParams.innerHTML = html;
    attachPmParamListeners();
  }

  function updatePmFormulaDisplay() {
    const method = pmState.method;
    const params = pmState.params[method];
    const methodInfo = normMethods[method];
    
    const formulaEl = document.getElementById("pmParamFormula");
    const exampleEl = document.getElementById("pmParamExample");
    
    if (formulaEl) formulaEl.textContent = `Formula: ${methodInfo.formula(params)}`;
    if (exampleEl) exampleEl.textContent = `Example: ${methodInfo.examples(params)}`;
  }

  function attachPmParamListeners() {
    const method = pmState.method;
    
    if (method === "exponential") {
      const inp = document.getElementById("pmParamDecay");
      if (inp) inp.addEventListener("input", () => {
        pmState.params.exponential.decay = Number(inp.value) || 0.85;
        updatePmFormulaDisplay();
        recomputePm();
      });
    } else if (method === "linear") {
      const inp = document.getElementById("pmParamThreshold");
      if (inp) inp.addEventListener("input", () => {
        pmState.params.linear.threshold = Number(inp.value) || 10;
        updatePmFormulaDisplay();
        recomputePm();
      });
    } else if (method === "inverse") {
      const inp = document.getElementById("pmParamK");
      if (inp) inp.addEventListener("input", () => {
        pmState.params.inverse.k = Number(inp.value) || 1;
        updatePmFormulaDisplay();
        recomputePm();
      });
    } else if (method === "logarithmic") {
      const inp = document.getElementById("pmParamMax");
      if (inp) inp.addEventListener("input", () => {
        pmState.params.logarithmic.maxExpected = Number(inp.value) || 20;
        updatePmFormulaDisplay();
        recomputePm();
      });
    } else if (method === "sigmoid") {
      const mid = document.getElementById("pmParamMidpoint");
      const steep = document.getElementById("pmParamSteepness");
      if (mid) mid.addEventListener("input", () => {
        pmState.params.sigmoid.midpoint = Number(mid.value) || 5;
        updatePmFormulaDisplay();
        recomputePm();
      });
      if (steep) steep.addEventListener("input", () => {
        pmState.params.sigmoid.steepness = Number(steep.value) || 1;
        updatePmFormulaDisplay();
        recomputePm();
      });
    }
  }

  // ---------- Render PM Table ----------
  function renderPmTable() {
    pmEl.tbody.innerHTML = "";
    
    pmState.problems.forEach((problem, idx) => {
      const tr = document.createElement("tr");
      tr.id = `pm-row-${idx}`;  // Add unique ID for direct linking
      
      tr.innerHTML = `
        <td><input type="text" value="${escapeHtml(problem.incident)}" style="width: 170px;" data-idx="${idx}" data-field="incident" /></td>
        <td>
          <select data-idx="${idx}" data-field="severity" style="width: 76px;">
            <option value="sev1" ${problem.severity === "sev1" ? "selected" : ""}>Sev1</option>
            <option value="sev2" ${problem.severity === "sev2" ? "selected" : ""}>Sev2</option>
            <option value="sev3" ${problem.severity === "sev3" ? "selected" : ""}>Sev3</option>
            <option value="sev4" ${problem.severity === "sev4" ? "selected" : ""}>Sev4</option>
          </select>
        </td>
        <td>
          <select data-idx="${idx}" data-field="problemType" style="width: 120px;">
            <option value="metadata" ${problem.problemType === "metadata" ? "selected" : ""}>Metadata</option>
            <option value="actions" ${problem.problemType === "actions" ? "selected" : ""}>Actions</option>
            <option value="postmortem" ${problem.problemType === "postmortem" ? "selected" : ""}>Postmortem</option>
          </select>
        </td>
        <td><input type="text" value="${escapeHtml(problem.description)}" style="width: 200px;" data-idx="${idx}" data-field="description" placeholder="Brief description..." /></td>
        <td><button class="btn danger" data-idx="${idx}">Remove</button></td>
      `;
      
      pmEl.tbody.appendChild(tr);
    });
    
    // Add event listeners
    pmEl.tbody.querySelectorAll("input, select").forEach(inp => {
      inp.addEventListener("input", () => {
        const idx = Number(inp.dataset.idx);
        const field = inp.dataset.field;
        pmState.problems[idx][field] = inp.value;
        recomputePm();
      });
      inp.addEventListener("change", () => {
        const idx = Number(inp.dataset.idx);
        const field = inp.dataset.field;
        pmState.problems[idx][field] = inp.value;
        recomputePm();
      });
    });
    
    pmEl.tbody.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("click", () => {
        const idx = Number(btn.dataset.idx);
        pmState.problems.splice(idx, 1);
        renderPmTable();
        recomputePm();
      });
    });
  }

  // ---------- PM Events ----------
  pmEl.wSev1.addEventListener("input", recomputePm);
  pmEl.wSev2.addEventListener("input", recomputePm);
  pmEl.wSev3.addEventListener("input", recomputePm);
  pmEl.wSev4.addEventListener("input", recomputePm);
  pmEl.wPostmortem.addEventListener("input", recomputePm);
  pmEl.wActions.addEventListener("input", recomputePm);
  pmEl.wMetadata.addEventListener("input", recomputePm);
  pmEl.budget.addEventListener("input", recomputePm);
  pmEl.method.addEventListener("change", () => {
    pmState.method = pmEl.method.value;
    renderPmMethodParams();
    recomputePm();
  });
  pmEl.showAllMethods.addEventListener("change", renderPmChart);

  function generateAlertId() {
    const num = Math.floor(Math.random() * 9000) + 1000; // 1000-9999
    return `ALERT-${num}`;
  }

  const problemDescriptions = {
    metadata: [
      "No timeline documented",
      "Impact scope unclear", 
      "Detection time not recorded",
      "Customer impact not quantified",
      "Missing affected services list"
    ],
    actions: [
      "Action items not assigned owners",
      "Missing due dates on actions",
      "Follow-up tasks incomplete",
      "Preventive measures not defined",
      "Monitoring gaps not addressed"
    ],
    postmortem: [
      "Postmortem not completed within SLA",
      "Missing root cause analysis",
      "No lessons learned section",
      "Review meeting not held",
      "Document not shared with stakeholders"
    ]
  };

  pmEl.addBtn.addEventListener("click", () => {
    // Generate a random ALERT-XXXX incident name
    const incident = generateAlertId();
    
    // Random severity, weighted towards sev2/sev3
    const severities = ["sev1", "sev2", "sev3", "sev4"];
    const sevWeights = [0.15, 0.35, 0.35, 0.15];
    const rand = Math.random();
    let severity = "sev2";
    let cumulative = 0;
    for (let i = 0; i < severities.length; i++) {
      cumulative += sevWeights[i];
      if (rand < cumulative) {
        severity = severities[i];
        break;
      }
    }
    
    // Random problem type, weighted towards metadata
    const problemTypes = ["metadata", "actions", "postmortem"];
    const typeWeights = [0.4, 0.4, 0.2];
    const typeRand = Math.random();
    let problemType = "metadata";
    cumulative = 0;
    for (let i = 0; i < problemTypes.length; i++) {
      cumulative += typeWeights[i];
      if (typeRand < cumulative) {
        problemType = problemTypes[i];
        break;
      }
    }
    
    // Pick a random description for the problem type
    const descriptions = problemDescriptions[problemType];
    const description = descriptions[Math.floor(Math.random() * descriptions.length)];
    
    pmState.problems.push({
      incident,
      severity,
      problemType,
      description
    });
    renderPmTable();
    recomputePm();
  });

  // ---------- PM Init ----------
  function syncPmControlsFromState() {
    pmEl.budget.value = pmState.budget;
    pmEl.method.value = pmState.method;
    pmEl.wSev1.value = pmState.severityWeights.sev1;
    pmEl.wSev2.value = pmState.severityWeights.sev2;
    pmEl.wSev3.value = pmState.severityWeights.sev3;
    pmEl.wSev4.value = pmState.severityWeights.sev4;
    pmEl.wPostmortem.value = pmState.typeWeights.postmortem;
    pmEl.wActions.value = pmState.typeWeights.actions;
    pmEl.wMetadata.value = pmState.typeWeights.metadata;
  }
  
  syncPmControlsFromState();
  renderPmMethodParams();
  renderPmTable();
  recomputePm();

  // ---------- Team Selector ----------
  const teamSelectorEl = document.getElementById('teamSelector');
  
  // Populate team selector
  function populateTeamSelector() {
    const teams = window.MockData.getAllTeamPaths();
    teamSelectorEl.innerHTML = teams.map((team, idx) => 
      `<option value="${idx}">${team.label}</option>`
    ).join('');
    teamSelectorEl.value = '0';
  }
  
  // Handle team selection change
  // Update dashboard link with current team path
  const dashboardLinkEl = document.getElementById('dashboardLink');
  const dataEditorLinkEl = document.getElementById('dataEditorLink');
  
  function updateDashboardLink() {
    if (currentTeamPath && dashboardLinkEl) {
      const teamParam = encodeURIComponent(JSON.stringify(currentTeamPath));
      dashboardLinkEl.href = `dashboard.html?team=${teamParam}`;
    }
  }
  
  function updateDataEditorLink() {
    if (currentTeamPath && dataEditorLinkEl) {
      const teamParam = encodeURIComponent(JSON.stringify(currentTeamPath));
      dataEditorLinkEl.href = `data-editor.html?team=${teamParam}`;
    }
  }

  // Handle navigation to a team path (shared logic for selector change and popstate)
  function handleTeamNavigation(path, updateSelector = true) {
    const teams = window.MockData.getAllTeamPaths();
    const teamIndex = TeamNavigation.findTeamIndex(teams, path);
    
    let targetIndex = teamIndex;
    if (targetIndex === -1 && teams.length > 0) {
      targetIndex = 0; // Default to first team
    }
    
    if (targetIndex === -1) return;
    
    currentTeamPath = teams[targetIndex].path;
    
    if (updateSelector) {
      teamSelectorEl.value = targetIndex.toString();
    }
    
    const teamData = loadTeamData(currentTeamPath);
    
    if (teamData) {
      // Update all state with new team data
      state.slos = teamData.slos;
      vulnState.images = teamData.images;
      bugState.tickets = teamData.tickets;
      pmState.problems = teamData.problems;
      
      // Re-render all sections
      renderTable();
      renderVulnTable();
      renderBugTable();
      renderPmTable();
      
      // Recompute all scores
      recompute();
      recomputeVuln();
      recomputeBug();
      recomputePm();
      
      // Update sidebar links
      updateDashboardLink();
      updateDataEditorLink();
    }
  }

  teamSelectorEl.addEventListener('change', () => {
    const idx = Number(teamSelectorEl.value);
    const teams = window.MockData.getAllTeamPaths();
    if (idx >= 0 && idx < teams.length) {
      currentTeamPath = teams[idx].path;
      // Update URL and localStorage via TeamNavigation
      TeamNavigation.navigateTo(currentTeamPath, null);
      handleTeamNavigation(currentTeamPath, false);
    }
  });
  
  populateTeamSelector();
  updateDashboardLink();
  updateDataEditorLink();

  // All sections initialized, enable state saving
  allSectionsInitialized = true;
  saveAllState(); // Save initial state

  // ---------- URL Parameter Handling ----------
  // Handle deep links from dashboard priority work items (scroll to specific item)
  function handleItemScroll() {
    const params = new URLSearchParams(window.location.search);
    const itemParam = params.get('item');
    
    if (!itemParam) return;
    
    const decodedItem = decodeURIComponent(itemParam);
    // Convert itemId (e.g., 'slo-0') to row ID (e.g., 'slo-row-0')
    const parts = decodedItem.split('-');
    if (parts.length === 2) {
      const [category, idx] = parts;
      const rowId = `${category}-row-${idx}`;
      
      // Wait for DOM to update, then scroll and highlight
      setTimeout(() => {
        const rowEl = document.getElementById(rowId);
        if (rowEl) {
          // Scroll to the row
          rowEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Add highlight effect
          rowEl.style.transition = 'background-color 0.3s ease';
          rowEl.style.backgroundColor = 'rgba(147, 197, 253, 0.3)';
          
          // Remove highlight after a moment
          setTimeout(() => {
            rowEl.style.backgroundColor = '';
            // Focus the first input in the row
            const firstInput = rowEl.querySelector('input, select');
            if (firstInput) {
              firstInput.focus();
            }
          }, 2000);
        } else {
          // If row not found, scroll to the section
          const sectionMap = {
            'slo': 'section-slos',
            'vuln': 'section-vulns',
            'bug': 'section-bugs',
            'pm': 'section-postmortems'
          };
          const sectionId = sectionMap[category];
          if (sectionId) {
            const sectionEl = document.getElementById(sectionId);
            if (sectionEl) {
              sectionEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          }
        }
      }, 100);
    }
  }
  
  // Initialize team navigation with popstate handling
  const initialPath = TeamNavigation.init((path) => {
    handleTeamNavigation(path, true);
  });
  handleTeamNavigation(initialPath, true);
  
  // Handle item scroll for deep links
  setTimeout(handleItemScroll, 50);
</script>
</body>
</html>
