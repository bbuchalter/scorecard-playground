<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Company Scorecards</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="scorecard-config.js"></script>
  <script src="scorecard-compute.js"></script>
  <script src="mock-data.js"></script>
  <style>
    :root {
      --bg: #0b1020;
      --panel: #111935;
      --panel2: #0f1730;
      --text: #e9eefc;
      --muted: #a9b4d6;
      --border: rgba(255,255,255,.10);
      --excellent: #6ee7b7;
      --good: #5eead4;
      --fair: #fde68a;
      --at-risk: #fb923c;
      --critical: #fb7185;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 600px at 10% 10%, rgba(147,197,253,.14), transparent),
                  radial-gradient(1000px 600px at 90% 20%, rgba(110,231,183,.10), transparent),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 40px 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .header {
      margin-bottom: 30px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 20px;
    }

    .header-left {
      flex: 1;
    }

    .header-actions {
      display: flex;
      gap: 10px;
      padding-top: 4px;
    }

    .title {
      font-size: 32px;
      font-weight: 800;
      margin: 0 0 12px 0;
      letter-spacing: -0.8px;
    }

    .breadcrumb {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 16px;
      color: var(--muted);
    }

    .breadcrumb-link {
      color: var(--text);
      text-decoration: none;
      transition: color 0.2s;
      font-weight: 600;
    }

    .breadcrumb-link:hover {
      color: var(--excellent);
    }

    .breadcrumb-separator {
      color: var(--muted);
      font-weight: 300;
    }

    .breadcrumb-current {
      color: var(--text);
      font-weight: 600;
    }

    .nav-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 10px 18px;
      background: rgba(255,255,255,.08);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text);
      font-size: 14px;
      font-weight: 600;
      text-decoration: none;
      transition: all 0.2s ease;
    }

    .nav-btn:hover {
      background: rgba(255,255,255,.14);
      border-color: rgba(255,255,255,.20);
      transform: translateY(-1px);
    }

    .view-selector {
      background: rgba(255,255,255,.06);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px 16px;
      color: var(--text);
      font-size: 14px;
      font-family: var(--sans);
      cursor: pointer;
    }

    .legend {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-bottom: 30px;
      padding: 16px 20px;
      background: rgba(255,255,255,.03);
      border-radius: 10px;
      border: 1px solid var(--border);
      font-size: 13px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-dot.excellent { background: var(--excellent); }
    .legend-dot.good { background: var(--good); }
    .legend-dot.fair { background: var(--fair); }
    .legend-dot.at-risk { background: var(--at-risk); }
    .legend-dot.critical { background: var(--critical); }

    .legend-trend {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-left: 20px;
    }

    .legend-trend svg {
      width: 30px;
      height: 16px;
    }

    .scorecard-table {
      width: 100%;
      background: var(--panel);
      border-radius: 12px;
      border: 1px solid var(--border);
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0,0,0,.3);
    }

    .scorecard-table table {
      width: 100%;
      border-collapse: collapse;
    }

    .scorecard-table thead {
      background: rgba(255,255,255,.04);
      border-bottom: 1px solid var(--border);
    }

    .scorecard-table th {
      padding: 16px 20px;
      text-align: left;
      font-size: 13px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .scorecard-table th:first-child {
      width: 200px;
      text-align: center;
    }

    .scorecard-table th:not(:first-child) {
      text-align: center;
    }

    .scorecard-table tbody tr {
      border-bottom: 1px solid var(--border);
      transition: background 0.15s;
    }

    .scorecard-table tbody tr.clickable {
      cursor: pointer;
    }

    .scorecard-table tbody tr:nth-child(even) {
      background: rgba(255,255,255,.02);
    }

    .scorecard-table tbody tr.clickable:hover {
      background: rgba(255,255,255,.08);
    }

    .scorecard-table tbody tr:last-child {
      border-bottom: none;
    }

    .scorecard-table td {
      padding: 20px;
    }

    .group-name {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .drill-down-icon {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--muted);
      font-size: 14px;
    }

    .clickable .drill-down-icon {
      color: var(--excellent);
    }

    .metric-cell {
      text-align: center;
    }

    .metric-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .score-badge {
      font-size: 20px;
      font-weight: 700;
      width: 48px;
      height: 48px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      letter-spacing: -0.5px;
    }

    .grade-badge {
      font-size: 32px;
      font-weight: 800;
      width: 64px;
      height: 64px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      letter-spacing: -0.5px;
    }

    .score-badge.excellent,
    .grade-badge.excellent {
      background: rgba(110,231,183,.18);
      color: var(--excellent);
      border: 1px solid rgba(110,231,183,.3);
    }

    .score-badge.good,
    .grade-badge.good {
      background: rgba(94,234,212,.18);
      color: var(--good);
      border: 1px solid rgba(94,234,212,.3);
    }

    .score-badge.fair,
    .grade-badge.fair {
      background: rgba(253,230,138,.18);
      color: var(--fair);
      border: 1px solid rgba(253,230,138,.3);
    }

    .score-badge.at-risk,
    .grade-badge.at-risk {
      background: rgba(251,146,60,.18);
      color: var(--at-risk);
      border: 1px solid rgba(251,146,60,.3);
    }

    .score-badge.critical,
    .grade-badge.critical {
      background: rgba(251,113,133,.18);
      color: var(--critical);
      border: 1px solid rgba(251,113,133,.3);
    }

    .sparkline-container {
      width: 100px;
      height: 32px;
      position: relative;
    }

    .current-avg {
      text-align: center;
      padding: 20px;
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
    }

    .current-avg-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .current-avg-value {
      font-size: 24px;
      font-weight: 700;
    }

    .current-avg-label {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }


    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: var(--muted);
    }

    .hero-section {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 900px) {
      .hero-section {
        grid-template-columns: 1fr;
      }
    }

    .hero-grade {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 20px;
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      border: 1px solid var(--border);
      position: relative;
    }

    .ownership-info {
      position: absolute;
      top: 12px;
      left: 12px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 11px;
      color: var(--muted);
      max-width: 160px;
    }

    .ownership-row {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }

    .ownership-role {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: rgba(169, 180, 214, 0.7);
    }

    .ownership-name {
      font-weight: 500;
      color: var(--text);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .hero-grade-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--muted);
      margin-bottom: 20px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .hero-grade-badge {
      font-size: 80px;
      font-weight: 900;
      width: 160px;
      height: 160px;
      border-radius: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      letter-spacing: -2px;
      margin-bottom: 16px;
    }

    .hero-grade-score {
      font-size: 32px;
      font-weight: 700;
      color: var(--text);
      font-family: var(--mono);
    }

    .hero-sparkline-container {
      width: 200px;
      height: 60px;
      position: relative;
      margin-top: 12px;
    }

    .hero-grade-badge.excellent {
      background: rgba(110,231,183,.18);
      color: var(--excellent);
      border: 2px solid rgba(110,231,183,.4);
    }

    .hero-grade-badge.good {
      background: rgba(94,234,212,.18);
      color: var(--good);
      border: 2px solid rgba(94,234,212,.4);
    }

    .hero-grade-badge.fair {
      background: rgba(253,230,138,.18);
      color: var(--fair);
      border: 2px solid rgba(253,230,138,.4);
    }

    .hero-grade-badge.at-risk {
      background: rgba(251,146,60,.18);
      color: var(--at-risk);
      border: 2px solid rgba(251,146,60,.4);
    }

    .hero-grade-badge.critical {
      background: rgba(251,113,133,.18);
      color: var(--critical);
      border: 2px solid rgba(251,113,133,.4);
    }

    .priority-work-panel {
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 24px;
      display: flex;
      flex-direction: column;
      position: relative;
    }

    .priority-work-title {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .8px;
      color: var(--muted);
      margin: 0 0 14px;
    }

    .priority-work-items {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
      overflow-y: auto;
      max-height: 400px;
    }

    .priority-item {
      display: block;
      text-decoration: none;
      padding: 10px;
      border-radius: 8px;
      background: rgba(255,255,255,.03);
      border: 1px solid rgba(255,255,255,.08);
      transition: background .15s, border-color .15s;
    }

    .priority-item:hover {
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.12);
    }

    .priority-item-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .priority-item-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .priority-item-category {
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: .6px;
      color: var(--muted);
    }

    .priority-item-opportunity {
      margin-left: auto;
      font-family: var(--mono);
      font-size: 11px;
      font-weight: 700;
      color: var(--good);
    }

    .priority-item-name {
      font-size: 12px;
      color: var(--text);
      line-height: 1.4;
      padding-left: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .priority-item-team {
      font-size: 10px;
      color: var(--muted);
      padding-left: 12px;
      margin-top: 2px;
    }

    .priority-empty {
      font-size: 11px;
      color: var(--muted);
      text-align: center;
      padding: 16px 0;
    }

    .hero-section-wrapper {
      margin-bottom: 30px;
    }

    .data-editor-link {
      display: inline-block;
      text-align: center;
      padding: 10px 14px;
      background: rgba(147,197,253,.12);
      border: 1px solid rgba(147,197,253,.24);
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text);
      text-decoration: none;
      transition: background .15s, border-color .15s;
    }

    .data-editor-link:hover {
      background: rgba(147,197,253,.20);
      border-color: rgba(147,197,253,.40);
    }

    .trend-chart-container {
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 24px;
      margin-bottom: 30px;
    }

    .trend-chart-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 16px;
    }

    .trend-chart-canvas {
      height: 250px;
    }

    /* Sub-team page layout: hero-grade + metrics trend stacked on left */
    .hero-section-subteam {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 900px) {
      .hero-section-subteam {
        grid-template-columns: 1fr;
      }
    }

    .hero-left-column {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .hero-grade-compact {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      border: 1px solid var(--border);
      position: relative;
    }

    .hero-grade-compact .hero-grade-title {
      font-size: 14px;
      margin-bottom: 12px;
    }

    .hero-grade-compact .hero-grade-badge {
      font-size: 48px;
      width: 90px;
      height: 90px;
      border-radius: 16px;
      margin-bottom: 8px;
    }

    .hero-grade-compact .hero-grade-score {
      font-size: 22px;
    }

    .hero-grade-compact .hero-sparkline-container {
      width: 140px;
      height: 40px;
      margin-top: 8px;
    }

    .hero-grade-compact .ownership-info {
      font-size: 9px;
      max-width: 120px;
    }

    .hero-grade-compact .ownership-role {
      font-size: 8px;
    }

    .trend-chart-inline {
      flex: 1;
      background: rgba(255,255,255,.03);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 16px;
      display: flex;
      flex-direction: column;
    }

    .trend-chart-inline .trend-chart-title {
      font-size: 11px;
      margin-bottom: 10px;
    }

    .trend-chart-inline .trend-chart-canvas {
      flex: 1;
      min-height: 120px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <h1 class="title">Company Scorecards</h1>
        <div class="breadcrumb" id="breadcrumb"></div>
      </div>
      <div class="header-actions">
        <a href="#" id="configLink" class="data-editor-link">⚙️ Scorecard Config</a>
        <a href="data-editor.html" class="data-editor-link">✏️ Data Editor</a>
      </div>
    </div>

    <div id="heroGradeContainer"></div>
    <div id="tableContainer"></div>
  </div>

<script>
  // ========== BUILD ORGANIZATION DATA FROM MOCK DATA ==========
  
  // Load configuration and mock data
  const config = window.ScorecardConfig.loadConfig();
  const mockData = window.MockData.loadMockData();
  const normMethods = window.ScorecardConfig.normMethods;
  const compute = window.ScorecardCompute;

  // Helper function to compute metrics for a team
  function computeTeamMetrics(teamData) {
    const sloResult = compute.computeSloScore(teamData.slos || [], config.slo, normMethods);
    const vulnResult = compute.computeVulnScore(teamData.images || [], config.vuln, normMethods);
    const bugResult = compute.computeBugScore(teamData.tickets || [], config.bug, normMethods);
    const pmResult = compute.computePmScore(teamData.problems || [], config.pm, normMethods);

    // Convert scores (0-100) to match dashboard format
    return {
      slos: { score: Math.round(sloResult.S * 100), trend: [85, 86, 87, Math.round(sloResult.S * 100)] },
      vulns: { score: Math.round(vulnResult.S * 100), trend: [72, 74, 75, Math.round(vulnResult.S * 100)] },
      bugs: { score: Math.round(bugResult.S * 100), trend: [78, 79, 80, Math.round(bugResult.S * 100)] },
      postmortems: { score: Math.round(pmResult.S * 100), trend: [58, 55, 53, Math.round(pmResult.S * 100)] }
    };
  }

  // Build organization data structure from mock data
  function buildOrganizationData() {
    const orgData = {};

    Object.keys(mockData).forEach(groupKey => {
      const groupMockData = mockData[groupKey];
      const hierarchy = window.MockData.organizationHierarchy[groupKey];
      
      orgData[groupKey] = {
        name: hierarchy.name,
        subTeams: Object.keys(hierarchy.teams),
        teams: {}
      };

      // Aggregate metrics for the group (average of all leaf teams)
      let groupMetricsSum = { slos: 0, vulns: 0, bugs: 0, postmortems: 0 };
      let leafTeamCount = 0;

      Object.keys(groupMockData.teams).forEach(teamKey => {
        const teamMockData = groupMockData.teams[teamKey];
        const teamHierarchy = hierarchy.teams[teamKey];

        if (teamMockData.subTeams) {
          // Team with sub-teams
          orgData[groupKey].teams[teamKey] = {
            subTeams: {}
          };

          let teamMetricsSum = { slos: 0, vulns: 0, bugs: 0, postmortems: 0 };
          let subTeamCount = 0;

          Object.keys(teamMockData.subTeams).forEach(subTeamKey => {
            const subTeamData = teamMockData.subTeams[subTeamKey];
            const metrics = computeTeamMetrics(subTeamData);
            
            orgData[groupKey].teams[teamKey].subTeams[subTeamKey] = {
              metrics: metrics
            };

            // Aggregate for team
            teamMetricsSum.slos += metrics.slos.score;
            teamMetricsSum.vulns += metrics.vulns.score;
            teamMetricsSum.bugs += metrics.bugs.score;
            teamMetricsSum.postmortems += metrics.postmortems.score;
            subTeamCount++;
            
            // Aggregate for group
            groupMetricsSum.slos += metrics.slos.score;
            groupMetricsSum.vulns += metrics.vulns.score;
            groupMetricsSum.bugs += metrics.bugs.score;
            groupMetricsSum.postmortems += metrics.postmortems.score;
            leafTeamCount++;
          });

          // Set team metrics as average of sub-teams
          orgData[groupKey].teams[teamKey].metrics = {
            slos: { score: Math.round(teamMetricsSum.slos / subTeamCount), trend: [85, 86, 87, Math.round(teamMetricsSum.slos / subTeamCount)] },
            vulns: { score: Math.round(teamMetricsSum.vulns / subTeamCount), trend: [72, 74, 75, Math.round(teamMetricsSum.vulns / subTeamCount)] },
            bugs: { score: Math.round(teamMetricsSum.bugs / subTeamCount), trend: [78, 79, 80, Math.round(teamMetricsSum.bugs / subTeamCount)] },
            postmortems: { score: Math.round(teamMetricsSum.postmortems / subTeamCount), trend: [58, 55, 53, Math.round(teamMetricsSum.postmortems / subTeamCount)] }
          };
        } else {
          // Leaf team
          const metrics = computeTeamMetrics(teamMockData);
          orgData[groupKey].teams[teamKey] = {
            metrics: metrics
          };

          // Aggregate for group
          groupMetricsSum.slos += metrics.slos.score;
          groupMetricsSum.vulns += metrics.vulns.score;
          groupMetricsSum.bugs += metrics.bugs.score;
          groupMetricsSum.postmortems += metrics.postmortems.score;
          leafTeamCount++;
        }
      });

      // Set group metrics as average of all leaf teams
      orgData[groupKey].metrics = {
        slos: { score: Math.round(groupMetricsSum.slos / leafTeamCount), trend: [85, 86, 87, Math.round(groupMetricsSum.slos / leafTeamCount)] },
        vulns: { score: Math.round(groupMetricsSum.vulns / leafTeamCount), trend: [72, 74, 75, Math.round(groupMetricsSum.vulns / leafTeamCount)] },
        bugs: { score: Math.round(groupMetricsSum.bugs / leafTeamCount), trend: [78, 79, 80, Math.round(groupMetricsSum.bugs / leafTeamCount)] },
        postmortems: { score: Math.round(groupMetricsSum.postmortems / leafTeamCount), trend: [58, 55, 53, Math.round(groupMetricsSum.postmortems / leafTeamCount)] }
      };
    });

    return orgData;
  }

  // Build organization data dynamically
  const organizationData = buildOrganizationData();

  // Original hardcoded data structure preserved for reference:
  /*
  const organizationData = {
    'Applications': {
      name: 'Applications',
      subTeams: ['Frontend', 'Backend API', 'Mobile Apps', 'Search & Discovery'],
      metrics: {
        slos: { score: 88, trend: [85, 86, 87, 88] },
        vulns: { score: 76, trend: [72, 74, 75, 76] },
        bugs: { score: 81, trend: [78, 79, 80, 81] },
        postmortems: { score: 52, trend: [58, 55, 53, 52] }
      },
      teams: {
        'Frontend': {
          metrics: {
            slos: { score: 95, trend: [92, 93, 94, 95] },
            vulns: { score: 82, trend: [78, 80, 81, 82] },
            bugs: { score: 74, trend: [70, 72, 73, 74] },
            postmortems: { score: 68, trend: [65, 66, 67, 68] }
          }
        },
        'Backend API': {
          metrics: {
            slos: { score: 92, trend: [89, 90, 91, 92] },
            vulns: { score: 58, trend: [55, 56, 57, 58] },
            bugs: { score: 88, trend: [85, 86, 87, 88] },
            postmortems: { score: 45, trend: [42, 43, 44, 45] }
          },
          subTeams: {
            'API Gateway': {
              metrics: {
                slos: { score: 95, trend: [92, 93, 94, 95] },
                vulns: { score: 62, trend: [59, 60, 61, 62] },
                bugs: { score: 89, trend: [86, 87, 88, 89] },
                postmortems: { score: 51, trend: [48, 49, 50, 51] }
              }
            },
            'Auth Service': {
              metrics: {
                slos: { score: 88, trend: [85, 86, 87, 88] },
                vulns: { score: 48, trend: [45, 46, 47, 48] },
                bugs: { score: 85, trend: [82, 83, 84, 85] },
                postmortems: { score: 38, trend: [35, 36, 37, 38] }
              }
            },
            'Payment Service': {
              metrics: {
                slos: { score: 93, trend: [90, 91, 92, 93] },
                vulns: { score: 64, trend: [61, 62, 63, 64] },
                bugs: { score: 90, trend: [87, 88, 89, 90] },
                postmortems: { score: 46, trend: [43, 44, 45, 46] }
              }
            }
          }
        },
        'Mobile Apps': {
          metrics: {
            slos: { score: 85, trend: [82, 83, 84, 85] },
            vulns: { score: 78, trend: [75, 76, 77, 78] },
            bugs: { score: 82, trend: [79, 80, 81, 82] },
            postmortems: { score: 48, trend: [45, 46, 47, 48] }
          }
        },
        'Search & Discovery': {
          metrics: {
            slos: { score: 81, trend: [78, 79, 80, 81] },
            vulns: { score: 86, trend: [83, 84, 85, 86] },
            bugs: { score: 79, trend: [76, 77, 78, 79] },
            postmortems: { score: 62, trend: [59, 60, 61, 62] }
          }
        }
      }
    },
    'Infrastructure': {
      name: 'Infrastructure',
      subTeams: ['Cloud Platform', 'Networking', 'Security', 'Database', 'Observability'],
      metrics: {
        slos: { score: 72, trend: [69, 70, 71, 72] },
        vulns: { score: 68, trend: [65, 66, 67, 68] },
        bugs: { score: 79, trend: [76, 77, 78, 79] },
        postmortems: { score: 58, trend: [55, 56, 57, 58] }
      },
      teams: {
        'Cloud Platform': {
          metrics: {
            slos: { score: 68, trend: [65, 66, 67, 68] },
            vulns: { score: 55, trend: [52, 53, 54, 55] },
            bugs: { score: 72, trend: [69, 70, 71, 72] },
            postmortems: { score: 62, trend: [59, 60, 61, 62] }
          },
          subTeams: {
            'AWS Infrastructure': {
              metrics: {
                slos: { score: 72, trend: [69, 70, 71, 72] },
                vulns: { score: 58, trend: [55, 56, 57, 58] },
                bugs: { score: 75, trend: [72, 73, 74, 75] },
                postmortems: { score: 68, trend: [65, 66, 67, 68] }
              }
            },
            'GCP Infrastructure': {
              metrics: {
                slos: { score: 65, trend: [62, 63, 64, 65] },
                vulns: { score: 51, trend: [48, 49, 50, 51] },
                bugs: { score: 69, trend: [66, 67, 68, 69] },
                postmortems: { score: 58, trend: [55, 56, 57, 58] }
              }
            },
            'Azure Infrastructure': {
              metrics: {
                slos: { score: 67, trend: [64, 65, 66, 67] },
                vulns: { score: 56, trend: [53, 54, 55, 56] },
                bugs: { score: 71, trend: [68, 69, 70, 71] },
                postmortems: { score: 60, trend: [57, 58, 59, 60] }
              }
            }
          }
        },
        'Networking': {
          metrics: {
            slos: { score: 76, trend: [73, 74, 75, 76] },
            vulns: { score: 71, trend: [68, 69, 70, 71] },
            bugs: { score: 83, trend: [80, 81, 82, 83] },
            postmortems: { score: 58, trend: [55, 56, 57, 58] }
          }
        },
        'Security': {
          metrics: {
            slos: { score: 78, trend: [75, 76, 77, 78] },
            vulns: { score: 92, trend: [89, 90, 91, 92] },
            bugs: { score: 85, trend: [82, 83, 84, 85] },
            postmortems: { score: 71, trend: [68, 69, 70, 71] }
          }
        },
        'Database': {
          metrics: {
            slos: { score: 65, trend: [62, 63, 64, 65] },
            vulns: { score: 58, trend: [55, 56, 57, 58] },
            bugs: { score: 74, trend: [71, 72, 73, 74] },
            postmortems: { score: 48, trend: [45, 46, 47, 48] }
          }
        },
        'Observability': {
          metrics: {
            slos: { score: 73, trend: [70, 71, 72, 73] },
            vulns: { score: 64, trend: [61, 62, 63, 64] },
            bugs: { score: 81, trend: [78, 79, 80, 81] },
            postmortems: { score: 52, trend: [49, 50, 51, 52] }
          }
        }
      }
    },
    'Growth': {
      name: 'Growth',
      subTeams: ['Marketing Automation', 'Analytics', 'A/B Testing', 'User Acquisition'],
      metrics: {
        slos: { score: 84, trend: [81, 82, 83, 84] },
        vulns: { score: 62, trend: [59, 60, 61, 62] },
        bugs: { score: 71, trend: [68, 69, 70, 71] },
        postmortems: { score: 66, trend: [63, 64, 65, 66] }
      },
      teams: {
        'Marketing Automation': {
          metrics: {
            slos: { score: 92, trend: [90, 91, 92, 92] },
            vulns: { score: 68, trend: [70, 69, 68, 68] },
            bugs: { score: 75, trend: [73, 74, 75, 75] },
            postmortems: { score: 65, trend: [66, 66, 65, 65] }
          }
        },
        'Analytics': {
          metrics: {
            slos: { score: 96, trend: [94, 95, 96, 96] },
            vulns: { score: 72, trend: [74, 73, 72, 72] },
            bugs: { score: 82, trend: [80, 81, 82, 82] },
            postmortems: { score: 70, trend: [71, 71, 70, 70] }
          }
        },
        'A/B Testing': {
          metrics: {
            slos: { score: 97, trend: [95, 96, 97, 97] },
            vulns: { score: 65, trend: [68, 67, 66, 65] },
            bugs: { score: 78, trend: [76, 77, 78, 78] },
            postmortems: { score: 72, trend: [73, 73, 72, 72] }
          }
        },
        'User Acquisition': {
          metrics: {
            slos: { score: 95, trend: [93, 94, 95, 95] },
            vulns: { score: 70, trend: [72, 71, 70, 70] },
            bugs: { score: 82, trend: [80, 81, 82, 82] },
            postmortems: { score: 68, trend: [69, 69, 68, 68] }
          }
        }
      }
    },
    'Platform': {
      name: 'Platform',
      subTeams: ['API Gateway', 'Authentication', 'Billing', 'Notifications'],
      metrics: {
        slos: { score: 86, trend: [83, 84, 85, 86] },
        vulns: { score: 73, trend: [70, 71, 72, 73] },
        bugs: { score: 68, trend: [65, 66, 67, 68] },
        postmortems: { score: 71, trend: [68, 69, 70, 71] }
      },
      teams: {
        'API Gateway': {
          metrics: {
            slos: { score: 93, trend: [91, 92, 93, 93] },
            vulns: { score: 82, trend: [84, 83, 82, 82] },
            bugs: { score: 68, trend: [70, 69, 68, 68] },
            postmortems: { score: 75, trend: [73, 74, 75, 75] }
          }
        },
        'Authentication': {
          metrics: {
            slos: { score: 98, trend: [96, 97, 98, 98] },
            vulns: { score: 85, trend: [86, 86, 85, 85] },
            bugs: { score: 72, trend: [74, 73, 72, 72] },
            postmortems: { score: 78, trend: [76, 77, 78, 78] }
          }
        },
        'Billing': {
          metrics: {
            slos: { score: 95, trend: [93, 94, 95, 95] },
            vulns: { score: 78, trend: [80, 79, 78, 78] },
            bugs: { score: 65, trend: [67, 66, 65, 65] },
            postmortems: { score: 68, trend: [66, 67, 68, 68] }
          }
        },
        'Notifications': {
          metrics: {
            slos: { score: 94, trend: [92, 93, 94, 94] },
            vulns: { score: 75, trend: [77, 76, 75, 75] },
            bugs: { score: 75, trend: [77, 76, 75, 75] },
            postmortems: { score: 68, trend: [66, 67, 68, 68] }
          }
        }
      }
    },
    'Data Engineering': {
      name: 'Data Engineering',
      subTeams: ['ETL Pipeline', 'Data Warehouse', 'ML Platform', 'Data Quality'],
      metrics: {
        slos: { score: 91, trend: [88, 89, 90, 91] },
        vulns: { score: 84, trend: [81, 82, 83, 84] },
        bugs: { score: 69, trend: [66, 67, 68, 69] },
        postmortems: { score: 43, trend: [40, 41, 42, 43] }
      },
      teams: {
        'ETL Pipeline': {
          metrics: {
            slos: { score: 98, trend: [96, 97, 98, 98] },
            vulns: { score: 95, trend: [94, 95, 95, 95] },
            bugs: { score: 82, trend: [80, 81, 82, 82] },
            postmortems: { score: 45, trend: [49, 47, 46, 45] }
          }
        },
        'Data Warehouse': {
          metrics: {
            slos: { score: 99, trend: [97, 98, 99, 99] },
            vulns: { score: 98, trend: [97, 98, 98, 98] },
            bugs: { score: 78, trend: [76, 77, 78, 78] },
            postmortems: { score: 50, trend: [54, 52, 51, 50] }
          }
        },
        'ML Platform': {
          metrics: {
            slos: { score: 100, trend: [98, 99, 100, 100] },
            vulns: { score: 96, trend: [95, 96, 96, 96] },
            bugs: { score: 85, trend: [83, 84, 85, 85] },
            postmortems: { score: 52, trend: [56, 54, 53, 52] }
          }
        },
        'Data Quality': {
          metrics: {
            slos: { score: 99, trend: [97, 98, 99, 99] },
            vulns: { score: 98, trend: [97, 98, 98, 98] },
            bugs: { score: 75, trend: [73, 74, 75, 75] },
            postmortems: { score: 45, trend: [49, 47, 46, 45] }
          }
        }
      }
    },
    'Mobile': {
      name: 'Mobile',
      subTeams: ['iOS', 'Android', 'React Native', 'Mobile Backend'],
      metrics: {
        slos: { score: 87, trend: [84, 85, 86, 87] },
        vulns: { score: 79, trend: [76, 77, 78, 79] },
        bugs: { score: 64, trend: [61, 62, 63, 64] },
        postmortems: { score: 67, trend: [64, 65, 66, 67] }
      },
      teams: {
        'iOS': {
          metrics: {
            slos: { score: 94, trend: [92, 93, 94, 94] },
            vulns: { score: 95, trend: [96, 96, 95, 95] },
            bugs: { score: 68, trend: [70, 69, 68, 68] },
            postmortems: { score: 72, trend: [70, 71, 72, 72] }
          }
        },
        'Android': {
          metrics: {
            slos: { score: 96, trend: [94, 95, 96, 96] },
            vulns: { score: 92, trend: [93, 93, 92, 92] },
            bugs: { score: 70, trend: [72, 71, 70, 70] },
            postmortems: { score: 68, trend: [66, 67, 68, 68] }
          }
        },
        'React Native': {
          metrics: {
            slos: { score: 93, trend: [91, 92, 93, 93] },
            vulns: { score: 90, trend: [91, 91, 90, 90] },
            bugs: { score: 72, trend: [74, 73, 72, 72] },
            postmortems: { score: 70, trend: [68, 69, 70, 70] }
          }
        },
        'Mobile Backend': {
          metrics: {
            slos: { score: 97, trend: [95, 96, 97, 97] },
            vulns: { score: 95, trend: [96, 96, 95, 95] },
            bugs: { score: 70, trend: [72, 71, 70, 70] },
            postmortems: { score: 70, trend: [68, 69, 70, 70] }
          }
        }
      }
    }
  };
  */

  // ========== STATE MANAGEMENT ==========
  let navigationPath = []; // Array to track path: [] = top-level, ['Applications'] = group, ['Applications', 'Backend API'] = team, ['Applications', 'Backend API', 'API Gateway'] = sub-team
  let chartInstances = {};

  // ========== HELPER FUNCTIONS (from shared scorecard-compute.js) ==========
  const getScoreClass = compute.getScoreClass;
  const getLetterGrade = compute.getLetterGrade;
  const getScoreColor = compute.getScoreColor;

  function createSparkline(canvasId, data, score) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    // Destroy existing chart if it exists
    if (chartInstances[canvasId]) {
      chartInstances[canvasId].destroy();
    }

    const color = getScoreColor(score);

    chartInstances[canvasId] = new Chart(ctx, {
      type: 'line',
      data: {
        labels: ['Q-3', 'Q-2', 'Q-1', 'Current'],
        datasets: [{
          data: data,
          borderColor: color,
          backgroundColor: 'transparent',
          borderWidth: 2,
          pointRadius: [0, 0, 0, 3],
          pointBackgroundColor: color,
          pointBorderColor: color,
          tension: 0.3
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: { enabled: false }
        },
        scales: {
          x: { display: false },
          y: { 
            display: false,
            beginAtZero: false,
            grace: '10%'
          }
        },
        elements: {
          line: {
            borderWidth: 2
          }
        }
      }
    });
  }

  function createFullLineChart(canvasId, metrics) {
    const ctx = document.getElementById(canvasId);
    if (!ctx) return;

    // Destroy existing chart if it exists
    if (chartInstances[canvasId]) {
      chartInstances[canvasId].destroy();
    }

    chartInstances[canvasId] = new Chart(ctx, {
      type: 'line',
      data: {
        labels: ['Q-3', 'Q-2', 'Q-1', 'Current'],
        datasets: [
          {
            label: 'SLOs',
            data: metrics.slos.trend,
            borderColor: '#93c5fd',
            backgroundColor: 'rgba(147, 197, 253, 0.1)',
            borderWidth: 2,
            pointRadius: 4,
            pointBackgroundColor: '#93c5fd',
            pointBorderColor: '#93c5fd',
            tension: 0.3
          },
          {
            label: 'Vulns',
            data: metrics.vulns.trend,
            borderColor: '#fb7185',
            backgroundColor: 'rgba(251, 113, 133, 0.1)',
            borderWidth: 2,
            pointRadius: 4,
            pointBackgroundColor: '#fb7185',
            pointBorderColor: '#fb7185',
            tension: 0.3
          },
          {
            label: 'Bugs',
            data: metrics.bugs.trend,
            borderColor: '#fde68a',
            backgroundColor: 'rgba(253, 230, 138, 0.1)',
            borderWidth: 2,
            pointRadius: 4,
            pointBackgroundColor: '#fde68a',
            pointBorderColor: '#fde68a',
            tension: 0.3
          },
          {
            label: 'Postmortems',
            data: metrics.postmortems.trend,
            borderColor: '#c4b5fd',
            backgroundColor: 'rgba(196, 181, 253, 0.1)',
            borderWidth: 2,
            pointRadius: 4,
            pointBackgroundColor: '#c4b5fd',
            pointBorderColor: '#c4b5fd',
            tension: 0.3
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            display: true,
            position: 'top',
            labels: {
              color: '#e9eefc',
              font: {
                size: 12,
                weight: '600'
              },
              padding: 15,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            enabled: true,
            mode: 'index',
            intersect: false,
            backgroundColor: 'rgba(17, 25, 53, 0.95)',
            titleColor: '#e9eefc',
            bodyColor: '#e9eefc',
            borderColor: 'rgba(255, 255, 255, 0.1)',
            borderWidth: 1,
            padding: 12,
            displayColors: true,
            callbacks: {
              label: function(context) {
                return context.dataset.label + ': ' + context.parsed.y;
              }
            }
          }
        },
        scales: {
          x: {
            display: true,
            grid: {
              display: false,
              color: 'rgba(255, 255, 255, 0.1)'
            },
            ticks: {
              color: '#a9b4d6',
              font: {
                size: 11
              }
            }
          },
          y: {
            display: true,
            min: 0,
            max: 100,
            grid: {
              color: 'rgba(255, 255, 255, 0.05)',
              borderDash: [3, 3]
            },
            ticks: {
              color: '#a9b4d6',
              font: {
                size: 11
              },
              callback: function(value) {
                return value;
              }
            }
          }
        },
        interaction: {
          mode: 'nearest',
          axis: 'x',
          intersect: false
        }
      }
    });
  }

  function calculateAverage(groupData) {
    const metrics = groupData.metrics;
    const scores = [
      metrics.slos.score,
      metrics.vulns.score,
      metrics.bugs.score,
      metrics.postmortems.score
    ];
    return Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
  }

  function calculateAverageTrend(groupData) {
    const metrics = groupData.metrics;
    const trend = [];
    for (let i = 0; i < 4; i++) {
      const periodAvg = Math.round(
        (metrics.slos.trend[i] + 
         metrics.vulns.trend[i] + 
         metrics.bugs.trend[i] + 
         metrics.postmortems.trend[i]) / 4
      );
      trend.push(periodAvg);
    }
    return trend;
  }

  // ========== HELPER FUNCTIONS ==========
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function getConfigUrl() {
    if (navigationPath.length === 0) {
      return 'index.html';
    }
    const teamParam = encodeURIComponent(JSON.stringify(navigationPath));
    return `index.html?team=${teamParam}`;
  }

  // Get ownership info for the current navigation level
  // Uses getOrGenerateOwnership to handle legacy data without ownership
  function getOwnershipInfo() {
    const getOrGenerate = window.MockData.getOrGenerateOwnership;
    
    if (navigationPath.length === 0) {
      // Top-level R&D - no specific ownership
      return null;
    } else if (navigationPath.length === 1) {
      // Group level - aggregate from first team with ownership
      const groupKey = navigationPath[0];
      const groupMockData = mockData[groupKey];
      if (groupMockData && groupMockData.teams) {
        const firstTeamKey = Object.keys(groupMockData.teams)[0];
        const firstTeam = groupMockData.teams[firstTeamKey];
        if (firstTeam.subTeams) {
          const firstSubTeamKey = Object.keys(firstTeam.subTeams)[0];
          return getOrGenerate(firstTeam.subTeams[firstSubTeamKey]);
        }
        return getOrGenerate(firstTeam);
      }
      return null;
    } else if (navigationPath.length === 2) {
      // Team level
      const groupKey = navigationPath[0];
      const teamKey = navigationPath[1];
      const groupMockData = mockData[groupKey];
      if (groupMockData && groupMockData.teams && groupMockData.teams[teamKey]) {
        const teamData = groupMockData.teams[teamKey];
        if (teamData.subTeams) {
          const firstSubTeamKey = Object.keys(teamData.subTeams)[0];
          return getOrGenerate(teamData.subTeams[firstSubTeamKey]);
        }
        return getOrGenerate(teamData);
      }
      return null;
    } else if (navigationPath.length === 3) {
      // Sub-team level
      const groupKey = navigationPath[0];
      const teamKey = navigationPath[1];
      const subTeamKey = navigationPath[2];
      const groupMockData = mockData[groupKey];
      if (groupMockData && groupMockData.teams && groupMockData.teams[teamKey] &&
          groupMockData.teams[teamKey].subTeams) {
        return getOrGenerate(groupMockData.teams[teamKey].subTeams[subTeamKey]);
      }
      return null;
    }
    return null;
  }

  function renderOwnershipHtml(ownership) {
    if (!ownership) return '';
    return `
      <div class="ownership-info">
        <div class="ownership-row">
          <span class="ownership-role">Engineering Manager</span>
          <span class="ownership-name">${escapeHtml(ownership.engineeringManager)}</span>
        </div>
        <div class="ownership-row">
          <span class="ownership-role">Product Manager</span>
          <span class="ownership-name">${escapeHtml(ownership.productManager)}</span>
        </div>
        <div class="ownership-row">
          <span class="ownership-role">Reliability DRI</span>
          <span class="ownership-name">${escapeHtml(ownership.reliabilityDRI)}</span>
        </div>
      </div>
    `;
  }

  function calculatePriorityWork() {
    const current = getCurrentData();
    
    // Get teams to process based on current navigation level
    function getTeamsToProcess() {
      const teams = [];
      
      if (current.type === 'top-level') {
        // Top-level: get all leaf teams
        Object.keys(mockData).forEach(groupKey => {
          const groupMockData = mockData[groupKey];
          const hierarchy = window.MockData.organizationHierarchy[groupKey];
          
          Object.keys(groupMockData.teams).forEach(teamKey => {
            const teamMockData = groupMockData.teams[teamKey];
            
            if (teamMockData.subTeams) {
              Object.keys(teamMockData.subTeams).forEach(subTeamKey => {
                teams.push({
                  data: teamMockData.subTeams[subTeamKey],
                  label: `${hierarchy.name} › ${teamKey} › ${subTeamKey}`,
                  path: [groupKey, teamKey, subTeamKey]
                });
              });
            } else {
              teams.push({
                data: teamMockData,
                label: `${hierarchy.name} › ${teamKey}`,
                path: [groupKey, teamKey]
              });
            }
          });
        });
      } else if (current.type === 'group') {
        // Group level: get all teams in this group
        const groupKey = navigationPath[0];
        const groupMockData = mockData[groupKey];
        
        if (groupMockData && groupMockData.teams) {
          Object.keys(groupMockData.teams).forEach(teamKey => {
            const teamMockData = groupMockData.teams[teamKey];
            
            if (teamMockData.subTeams) {
              Object.keys(teamMockData.subTeams).forEach(subTeamKey => {
                teams.push({
                  data: teamMockData.subTeams[subTeamKey],
                  label: `${teamKey} › ${subTeamKey}`,
                  path: [groupKey, teamKey, subTeamKey]
                });
              });
            } else {
              teams.push({
                data: teamMockData,
                label: teamKey,
                path: [groupKey, teamKey]
              });
            }
          });
        }
      } else if (current.type === 'team') {
        // Team level: get this team or its sub-teams
        const groupKey = navigationPath[0];
        const teamKey = navigationPath[1];
        const groupMockData = mockData[groupKey];
        
        if (groupMockData && groupMockData.teams && groupMockData.teams[teamKey]) {
          const teamMockData = groupMockData.teams[teamKey];
          
          if (teamMockData.subTeams) {
            Object.keys(teamMockData.subTeams).forEach(subTeamKey => {
              teams.push({
                data: teamMockData.subTeams[subTeamKey],
                label: subTeamKey,
                path: [groupKey, teamKey, subTeamKey]
              });
            });
          } else {
            teams.push({
              data: teamMockData,
              label: teamKey,
              path: [groupKey, teamKey]
            });
          }
        }
      } else if (current.type === 'sub-team') {
        // Sub-team level: just this sub-team
        const groupKey = navigationPath[0];
        const teamKey = navigationPath[1];
        const subTeamKey = navigationPath[2];
        const groupMockData = mockData[groupKey];
        
        if (groupMockData && groupMockData.teams && groupMockData.teams[teamKey] && 
            groupMockData.teams[teamKey].subTeams && groupMockData.teams[teamKey].subTeams[subTeamKey]) {
          teams.push({
            data: groupMockData.teams[teamKey].subTeams[subTeamKey],
            label: subTeamKey,
            path: [groupKey, teamKey, subTeamKey]
          });
        }
      }
      
      return teams;
    }
    
    // Use the shared function from scorecard-compute.js
    const teamsToProcess = getTeamsToProcess();
    return compute.calculateOpportunitiesForTeams(teamsToProcess, config, normMethods, 5);
  }

  function renderPriorityWork() {
    const opportunities = calculatePriorityWork();
    
    if (opportunities.length === 0) {
      return '<div class="priority-empty">✓ All items at max score!</div>';
    }
    
    return opportunities.map(opp => {
      // Build URL with team path and item ID
      const teamPathParam = opp.teamPath ? encodeURIComponent(JSON.stringify(opp.teamPath)) : '';
      const itemParam = encodeURIComponent(opp.itemId);
      const href = `index.html?team=${teamPathParam}&item=${itemParam}`;
      
      return `
        <a href="${href}" class="priority-item">
          <div class="priority-item-header">
            <span class="priority-item-dot" style="background: ${opp.categoryColor};"></span>
            <span class="priority-item-category">${opp.category}</span>
            <span class="priority-item-opportunity">+${opp.opportunity.toFixed(2)} pts</span>
          </div>
          <div class="priority-item-name">${escapeHtml(opp.name)}</div>
          <div class="priority-item-team">${escapeHtml(opp.team)}</div>
        </a>
      `;
    }).join('');
  }

  // ========== RENDER FUNCTIONS ==========
  function renderBreadcrumb() {
    const breadcrumbEl = document.getElementById('breadcrumb');
    
    if (navigationPath.length === 0) {
      breadcrumbEl.innerHTML = '<span class="breadcrumb-current">R&D Groups</span>';
    } else if (navigationPath.length === 1) {
      const groupName = organizationData[navigationPath[0]].name;
      breadcrumbEl.innerHTML = `
        <a href="#" class="breadcrumb-link" onclick="navigateToTopLevel(); return false;">R&D</a>
        <span class="breadcrumb-separator">›</span>
        <span class="breadcrumb-current">${groupName}</span>
      `;
    } else if (navigationPath.length === 2) {
      const groupName = organizationData[navigationPath[0]].name;
      const teamName = navigationPath[1];
      breadcrumbEl.innerHTML = `
        <a href="#" class="breadcrumb-link" onclick="navigateToTopLevel(); return false;">R&D</a>
        <span class="breadcrumb-separator">›</span>
        <a href="#" class="breadcrumb-link" onclick="navigateToGroup('${navigationPath[0]}'); return false;">${groupName}</a>
        <span class="breadcrumb-separator">›</span>
        <span class="breadcrumb-current">${teamName}</span>
      `;
    } else if (navigationPath.length === 3) {
      const groupName = organizationData[navigationPath[0]].name;
      const teamName = navigationPath[1];
      const subTeamName = navigationPath[2];
      breadcrumbEl.innerHTML = `
        <a href="#" class="breadcrumb-link" onclick="navigateToTopLevel(); return false;">R&D</a>
        <span class="breadcrumb-separator">›</span>
        <a href="#" class="breadcrumb-link" onclick="navigateToGroup('${navigationPath[0]}'); return false;">${groupName}</a>
        <span class="breadcrumb-separator">›</span>
        <a href="#" class="breadcrumb-link" onclick="navigateToTeam('${navigationPath[0]}', '${navigationPath[1]}'); return false;">${teamName}</a>
        <span class="breadcrumb-separator">›</span>
        <span class="breadcrumb-current">${subTeamName}</span>
      `;
    }
  }

  function getCurrentData() {
    if (navigationPath.length === 0) {
      // Top-level: all groups
      return { type: 'top-level', data: organizationData };
    } else if (navigationPath.length === 1) {
      // Group level
      return { type: 'group', data: organizationData[navigationPath[0]] };
    } else if (navigationPath.length === 2) {
      // Team level
      const group = organizationData[navigationPath[0]];
      const team = group.teams[navigationPath[1]];
      return { type: 'team', data: team, parentData: group };
    } else if (navigationPath.length === 3) {
      // Sub-team level (leaf)
      const group = organizationData[navigationPath[0]];
      const team = group.teams[navigationPath[1]];
      const subTeam = team.subTeams[navigationPath[2]];
      return { type: 'sub-team', data: subTeam, teamName: navigationPath[2] };
    }
  }

  function renderHeroGrade() {
    const container = document.getElementById('heroGradeContainer');
    const current = getCurrentData();
    
    if (current.type === 'top-level') {
      // Calculate overall R&D grade
      const topLevelGroups = Object.keys(organizationData);
      let totalScore = 0;
      let totalTrendScores = [0, 0, 0, 0];
      
      topLevelGroups.forEach(groupKey => {
        const group = organizationData[groupKey];
        const avg = calculateAverage(group);
        totalScore += avg;
        
        const trend = calculateAverageTrend(group);
        trend.forEach((val, i) => {
          totalTrendScores[i] += val;
        });
      });
      
      const overallAvg = Math.round(totalScore / topLevelGroups.length);
      const overallTrend = totalTrendScores.map(t => Math.round(t / topLevelGroups.length));
      const avgClass = getScoreClass(overallAvg);
      const letterGrade = getLetterGrade(overallAvg);
      
      container.innerHTML = `
        <div class="hero-section-wrapper">
          <div class="hero-section">
            <div class="hero-grade">
              <div class="hero-grade-title">R&D</div>
              <div class="hero-grade-badge ${avgClass}">${letterGrade}</div>
              <div class="hero-grade-score">${overallAvg}/100</div>
              <div class="hero-sparkline-container">
                <canvas id="chart-hero-grade"></canvas>
              </div>
            </div>
            <div class="priority-work-panel">
              <h3 class="priority-work-title">Top 5 Opportunities</h3>
              <div class="priority-work-items">
                ${renderPriorityWork()}
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Create hero sparkline
      setTimeout(() => {
        createSparkline('chart-hero-grade', overallTrend, overallAvg);
      }, 0);
    } else if (current.type === 'group') {
      const ownership = getOwnershipInfo();
      // Show specific group grade
      const group = current.data;
      const avg = calculateAverage(group);
      const trend = calculateAverageTrend(group);
      const avgClass = getScoreClass(avg);
      const letterGrade = getLetterGrade(avg);
      
      container.innerHTML = `
        <div class="hero-section-wrapper">
          <div class="hero-section">
            <div class="hero-grade">
              ${renderOwnershipHtml(ownership)}
              <div class="hero-grade-title">${group.name}</div>
              <div class="hero-grade-badge ${avgClass}">${letterGrade}</div>
              <div class="hero-grade-score">${avg}/100</div>
              <div class="hero-sparkline-container">
                <canvas id="chart-hero-grade"></canvas>
              </div>
            </div>
            <div class="priority-work-panel">
              <h3 class="priority-work-title">Top 5 Opportunities</h3>
              <div class="priority-work-items">
                ${renderPriorityWork()}
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Create hero sparkline
      setTimeout(() => {
        createSparkline('chart-hero-grade', trend, avg);
      }, 0);
    } else if (current.type === 'team') {
      const ownership = getOwnershipInfo();
      // Show specific team grade
      const team = current.data;
      const teamName = navigationPath[1];
      const metrics = team.metrics;
      const scores = [metrics.slos.score, metrics.vulns.score, metrics.bugs.score, metrics.postmortems.score];
      const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
      
      // Calculate trend
      const avgTrend = [];
      for (let i = 0; i < 4; i++) {
        avgTrend.push(Math.round(
          (metrics.slos.trend[i] + metrics.vulns.trend[i] + 
           metrics.bugs.trend[i] + metrics.postmortems.trend[i]) / 4
        ));
      }
      
      const avgClass = getScoreClass(avg);
      const letterGrade = getLetterGrade(avg);
      
      container.innerHTML = `
        <div class="hero-section-wrapper">
          <div class="hero-section">
            <div class="hero-grade">
              ${renderOwnershipHtml(ownership)}
              <div class="hero-grade-title">${teamName}</div>
              <div class="hero-grade-badge ${avgClass}">${letterGrade}</div>
              <div class="hero-grade-score">${avg}/100</div>
              <div class="hero-sparkline-container">
                <canvas id="chart-hero-grade"></canvas>
              </div>
            </div>
            <div class="priority-work-panel">
              <h3 class="priority-work-title">Top 5 Opportunities</h3>
              <div class="priority-work-items">
                ${renderPriorityWork()}
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Create hero sparkline
      setTimeout(() => {
        createSparkline('chart-hero-grade', avgTrend, avg);
      }, 0);
    } else if (current.type === 'sub-team') {
      const ownership = getOwnershipInfo();
      // Show specific sub-team grade (leaf node - hero only)
      const subTeam = current.data;
      const subTeamName = current.teamName;
      const metrics = subTeam.metrics;
      const scores = [metrics.slos.score, metrics.vulns.score, metrics.bugs.score, metrics.postmortems.score];
      const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
      
      // Calculate trend
      const avgTrend = [];
      for (let i = 0; i < 4; i++) {
        avgTrend.push(Math.round(
          (metrics.slos.trend[i] + metrics.vulns.trend[i] + 
           metrics.bugs.trend[i] + metrics.postmortems.trend[i]) / 4
        ));
      }
      
      const avgClass = getScoreClass(avg);
      const letterGrade = getLetterGrade(avg);
      const safeId = subTeamName.replace(/[^a-zA-Z0-9]/g, '-');
      
      container.innerHTML = `
        <div class="hero-section-wrapper">
          <div class="hero-section-subteam">
            <div class="hero-left-column">
              <div class="hero-grade-compact">
                ${renderOwnershipHtml(ownership)}
                <div class="hero-grade-title">${subTeamName}</div>
                <div class="hero-grade-badge ${avgClass}">${letterGrade}</div>
                <div class="hero-grade-score">${avg}/100</div>
              </div>
              <div class="trend-chart-inline">
                <div class="trend-chart-title">Metrics Trend</div>
                <div class="trend-chart-canvas">
                  <canvas id="chart-trend-${safeId}"></canvas>
                </div>
              </div>
            </div>
            <div class="priority-work-panel">
              <h3 class="priority-work-title">Top 5 Opportunities</h3>
              <div class="priority-work-items">
                ${renderPriorityWork()}
              </div>
            </div>
          </div>
        </div>
      `;
      
      // Create trend chart
      setTimeout(() => {
        createFullLineChart(`chart-trend-${safeId}`, metrics);
      }, 0);
    }
  }


  function renderTopLevel() {
    const topLevelGroups = Object.keys(organizationData);
    
    let html = `
      <div class="scorecard-table">
        <table>
          <thead>
            <tr>
              <th>Group</th>
              <th>SLOs</th>
              <th>Vulns</th>
              <th>Bugs</th>
              <th>Postmortems</th>
            </tr>
          </thead>
          <tbody>
    `;

    topLevelGroups.forEach(groupKey => {
      const group = organizationData[groupKey];
      const avg = calculateAverage(group);
      const avgClass = getScoreClass(avg);
      const letterGrade = getLetterGrade(avg);
      const avgTrend = calculateAverageTrend(group);
      
      html += `
        <tr class="clickable" onclick="navigateToGroup('${groupKey}')">
          <td class="metric-cell">
            <div class="metric-content">
              <div class="group-name" style="text-align: center; margin-bottom: 8px;">
                ${group.name}
                <span class="drill-down-icon">›</span>
              </div>
              <div class="grade-badge ${avgClass}">${letterGrade}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-grade"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(group.metrics.slos.score)}">${group.metrics.slos.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-slos"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(group.metrics.vulns.score)}">${group.metrics.vulns.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-vulns"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(group.metrics.bugs.score)}">${group.metrics.bugs.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-bugs"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(group.metrics.postmortems.score)}">${group.metrics.postmortems.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-postmortems"></canvas>
              </div>
            </div>
          </td>
        </tr>
      `;
    });

    html += `
          </tbody>
        </table>
      </div>
    `;

    document.getElementById('tableContainer').innerHTML = html;

    // Create sparklines
    setTimeout(() => {
      topLevelGroups.forEach(groupKey => {
        const group = organizationData[groupKey];
        const avg = calculateAverage(group);
        const avgTrend = calculateAverageTrend(group);
        createSparkline(`chart-${groupKey}-grade`, avgTrend, avg);
        createSparkline(`chart-${groupKey}-slos`, group.metrics.slos.trend, group.metrics.slos.score);
        createSparkline(`chart-${groupKey}-vulns`, group.metrics.vulns.trend, group.metrics.vulns.score);
        createSparkline(`chart-${groupKey}-bugs`, group.metrics.bugs.trend, group.metrics.bugs.score);
        createSparkline(`chart-${groupKey}-postmortems`, group.metrics.postmortems.trend, group.metrics.postmortems.score);
      });
    }, 0);
  }

  function renderGroupDetail(groupKey) {
    const group = organizationData[groupKey];
    const teams = group.teams;
    const teamKeys = Object.keys(teams);

    let html = `
      <div class="scorecard-table">
        <table>
          <thead>
            <tr>
              <th>Team</th>
              <th>SLOs</th>
              <th>Vulns</th>
              <th>Bugs</th>
              <th>Postmortems</th>
            </tr>
          </thead>
          <tbody>
    `;

    teamKeys.forEach(teamKey => {
      const team = teams[teamKey];
      const metrics = team.metrics;
      const scores = [
        metrics.slos.score,
        metrics.vulns.score,
        metrics.bugs.score,
        metrics.postmortems.score
      ];
      const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
      const avgClass = getScoreClass(avg);
      const letterGrade = getLetterGrade(avg);
      const avgTrend = [];
      for (let i = 0; i < 4; i++) {
        avgTrend.push(Math.round(
          (metrics.slos.trend[i] + metrics.vulns.trend[i] + 
           metrics.bugs.trend[i] + metrics.postmortems.trend[i]) / 4
        ));
      }
      
      const hasSubTeams = team.subTeams && Object.keys(team.subTeams).length > 0;
      const clickableClass = 'clickable';
      const clickHandler = `onclick="navigateToTeam('${groupKey}', '${teamKey}')"`;
      const drillIcon = hasSubTeams ? '<span class="drill-down-icon">›</span>' : '';
      
      html += `
        <tr class="${clickableClass}" ${clickHandler}>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="group-name" style="text-align: center; margin-bottom: 8px;">
                ${teamKey}
                ${drillIcon}
              </div>
              <div class="grade-badge ${avgClass}">${letterGrade}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-grade"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(metrics.slos.score)}">${metrics.slos.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-slos"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(metrics.vulns.score)}">${metrics.vulns.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-vulns"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(metrics.bugs.score)}">${metrics.bugs.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-bugs"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(metrics.postmortems.score)}">${metrics.postmortems.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-postmortems"></canvas>
              </div>
            </div>
          </td>
        </tr>
      `;
    });

    html += `
          </tbody>
        </table>
      </div>
    `;

    document.getElementById('tableContainer').innerHTML = html;

    // Create sparklines
    setTimeout(() => {
      teamKeys.forEach(teamKey => {
        const team = teams[teamKey];
        const metrics = team.metrics;
        const scores = [metrics.slos.score, metrics.vulns.score, metrics.bugs.score, metrics.postmortems.score];
        const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
        const avgTrend = [];
        for (let i = 0; i < 4; i++) {
          avgTrend.push(Math.round(
            (metrics.slos.trend[i] + metrics.vulns.trend[i] + 
             metrics.bugs.trend[i] + metrics.postmortems.trend[i]) / 4
          ));
        }
        createSparkline(`chart-${groupKey}-${teamKey}-grade`, avgTrend, avg);
        createSparkline(`chart-${groupKey}-${teamKey}-slos`, metrics.slos.trend, metrics.slos.score);
        createSparkline(`chart-${groupKey}-${teamKey}-vulns`, metrics.vulns.trend, metrics.vulns.score);
        createSparkline(`chart-${groupKey}-${teamKey}-bugs`, metrics.bugs.trend, metrics.bugs.score);
        createSparkline(`chart-${groupKey}-${teamKey}-postmortems`, metrics.postmortems.trend, metrics.postmortems.score);
      });
    }, 0);
  }

  function renderSingleTeamTable(teamName, metrics) {
    const scores = [
      metrics.slos.score,
      metrics.vulns.score,
      metrics.bugs.score,
      metrics.postmortems.score
    ];
    const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
    const avgClass = getScoreClass(avg);
    const letterGrade = getLetterGrade(avg);
    const avgTrend = [];
    for (let i = 0; i < 4; i++) {
      avgTrend.push(Math.round(
        (metrics.slos.trend[i] + metrics.vulns.trend[i] + 
         metrics.bugs.trend[i] + metrics.postmortems.trend[i]) / 4
      ));
    }

    // Sanitize teamName for use in canvas IDs (replace spaces and special chars)
    const safeId = teamName.replace(/[^a-zA-Z0-9]/g, '-');

    // Trend chart is now shown inline in the hero section for leaf pages
    const isLeafPage = navigationPath.length >= 2;
    const trendChartHtml = isLeafPage ? '' : `
      <div class="trend-chart-container">
        <div class="trend-chart-title">Metrics Trend</div>
        <div class="trend-chart-canvas">
          <canvas id="chart-trend-${safeId}"></canvas>
        </div>
      </div>
    `;

    const html = `
      ${trendChartHtml}
      <div class="scorecard-table">
        <table>
          <thead>
            <tr>
              <th>Sub-Team</th>
              <th>SLOs</th>
              <th>Vulns</th>
              <th>Bugs</th>
              <th>Postmortems</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td class="metric-cell">
                <div class="metric-content">
                  <div class="group-name" style="text-align: center; margin-bottom: 8px;">${teamName}</div>
                  <div class="grade-badge ${avgClass}">${letterGrade}</div>
                  <div class="sparkline-container">
                    <canvas id="chart-single-${safeId}-grade"></canvas>
                  </div>
                </div>
              </td>
              <td class="metric-cell">
                <div class="metric-content">
                  <div class="score-badge ${getScoreClass(metrics.slos.score)}">${metrics.slos.score}</div>
                  <div class="sparkline-container">
                    <canvas id="chart-single-${safeId}-slos"></canvas>
                  </div>
                </div>
              </td>
              <td class="metric-cell">
                <div class="metric-content">
                  <div class="score-badge ${getScoreClass(metrics.vulns.score)}">${metrics.vulns.score}</div>
                  <div class="sparkline-container">
                    <canvas id="chart-single-${safeId}-vulns"></canvas>
                  </div>
                </div>
              </td>
              <td class="metric-cell">
                <div class="metric-content">
                  <div class="score-badge ${getScoreClass(metrics.bugs.score)}">${metrics.bugs.score}</div>
                  <div class="sparkline-container">
                    <canvas id="chart-single-${safeId}-bugs"></canvas>
                  </div>
                </div>
              </td>
              <td class="metric-cell">
                <div class="metric-content">
                  <div class="score-badge ${getScoreClass(metrics.postmortems.score)}">${metrics.postmortems.score}</div>
                  <div class="sparkline-container">
                    <canvas id="chart-single-${safeId}-postmortems"></canvas>
                  </div>
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    `;

    document.getElementById('tableContainer').innerHTML = html;

    // Create trend chart (only if not on leaf page) and sparklines
    setTimeout(() => {
      if (!isLeafPage) {
        createFullLineChart(`chart-trend-${safeId}`, metrics);
      }
      createSparkline(`chart-single-${safeId}-grade`, avgTrend, avg);
      createSparkline(`chart-single-${safeId}-slos`, metrics.slos.trend, metrics.slos.score);
      createSparkline(`chart-single-${safeId}-vulns`, metrics.vulns.trend, metrics.vulns.score);
      createSparkline(`chart-single-${safeId}-bugs`, metrics.bugs.trend, metrics.bugs.score);
      createSparkline(`chart-single-${safeId}-postmortems`, metrics.postmortems.trend, metrics.postmortems.score);
    }, 0);
  }

  function updateHeaderButtons() {
    // Update the config link based on current navigation path
    const configLink = document.getElementById('configLink');
    if (configLink) {
      configLink.href = getConfigUrl();
    }
  }

  function render() {
    renderBreadcrumb();
    updateHeaderButtons();
    renderHeroGrade();
    
    if (navigationPath.length === 0) {
      renderTopLevel();
    } else if (navigationPath.length === 1) {
      renderGroupDetail(navigationPath[0]);
    } else if (navigationPath.length === 2) {
      // Check if this team has sub-teams
      const group = organizationData[navigationPath[0]];
      const team = group.teams[navigationPath[1]];
      if (team.subTeams && Object.keys(team.subTeams).length > 0) {
        renderTeamDetail(navigationPath[0], navigationPath[1]);
      } else {
        // Leaf node at team level - show single team table
        renderSingleTeamTable(navigationPath[1], team.metrics);
      }
    } else if (navigationPath.length === 3) {
      // Leaf node at sub-team level - no table needed, hero section has all info
      document.getElementById('tableContainer').innerHTML = '';
    }
  }

  function renderTeamDetail(groupKey, teamKey) {
    const group = organizationData[groupKey];
    const team = group.teams[teamKey];
    const subTeams = team.subTeams;
    const subTeamKeys = Object.keys(subTeams);

    let html = `
      <div class="scorecard-table">
        <table>
          <thead>
            <tr>
              <th>Sub-Team</th>
              <th>SLOs</th>
              <th>Vulns</th>
              <th>Bugs</th>
              <th>Postmortems</th>
            </tr>
          </thead>
          <tbody>
    `;

    subTeamKeys.forEach(subTeamKey => {
      const subTeam = subTeams[subTeamKey];
      const metrics = subTeam.metrics;
      const scores = [
        metrics.slos.score,
        metrics.vulns.score,
        metrics.bugs.score,
        metrics.postmortems.score
      ];
      const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
      const avgClass = getScoreClass(avg);
      const letterGrade = getLetterGrade(avg);
      
      html += `
        <tr class="clickable" onclick="navigateToSubTeam('${groupKey}', '${teamKey}', '${subTeamKey}')">
          <td class="metric-cell">
            <div class="metric-content">
              <div class="group-name" style="text-align: center; margin-bottom: 8px;">${subTeamKey}</div>
              <div class="grade-badge ${avgClass}">${letterGrade}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-${subTeamKey}-grade"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(metrics.slos.score)}">${metrics.slos.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-${subTeamKey}-slos"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(metrics.vulns.score)}">${metrics.vulns.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-${subTeamKey}-vulns"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(metrics.bugs.score)}">${metrics.bugs.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-${subTeamKey}-bugs"></canvas>
              </div>
            </div>
          </td>
          <td class="metric-cell">
            <div class="metric-content">
              <div class="score-badge ${getScoreClass(metrics.postmortems.score)}">${metrics.postmortems.score}</div>
              <div class="sparkline-container">
                <canvas id="chart-${groupKey}-${teamKey}-${subTeamKey}-postmortems"></canvas>
              </div>
            </div>
          </td>
        </tr>
      `;
    });

    html += `
          </tbody>
        </table>
      </div>
    `;

    document.getElementById('tableContainer').innerHTML = html;

    // Create sparklines
    setTimeout(() => {
      subTeamKeys.forEach(subTeamKey => {
        const subTeam = subTeams[subTeamKey];
        const metrics = subTeam.metrics;
        const scores = [metrics.slos.score, metrics.vulns.score, metrics.bugs.score, metrics.postmortems.score];
        const avg = Math.round(scores.reduce((a, b) => a + b, 0) / scores.length);
        const avgTrend = [];
        for (let i = 0; i < 4; i++) {
          avgTrend.push(Math.round(
            (metrics.slos.trend[i] + metrics.vulns.trend[i] + 
             metrics.bugs.trend[i] + metrics.postmortems.trend[i]) / 4
          ));
        }
        createSparkline(`chart-${groupKey}-${teamKey}-${subTeamKey}-grade`, avgTrend, avg);
        createSparkline(`chart-${groupKey}-${teamKey}-${subTeamKey}-slos`, metrics.slos.trend, metrics.slos.score);
        createSparkline(`chart-${groupKey}-${teamKey}-${subTeamKey}-vulns`, metrics.vulns.trend, metrics.vulns.score);
        createSparkline(`chart-${groupKey}-${teamKey}-${subTeamKey}-bugs`, metrics.bugs.trend, metrics.bugs.score);
        createSparkline(`chart-${groupKey}-${teamKey}-${subTeamKey}-postmortems`, metrics.postmortems.trend, metrics.postmortems.score);
      });
    }, 0);
  }

  // ========== NAVIGATION ==========
  function updateUrl(path, pushState = true) {
    const url = new URL(window.location);
    if (path.length > 0) {
      url.searchParams.set('team', JSON.stringify(path));
    } else {
      url.searchParams.delete('team');
    }
    
    if (pushState) {
      history.pushState({ navigationPath: path }, '', url);
    } else {
      history.replaceState({ navigationPath: path }, '', url);
    }
  }

  function navigateToGroup(groupKey) {
    navigationPath = [groupKey];
    updateUrl(navigationPath);
    render();
  }

  function navigateToTeam(groupKey, teamKey) {
    navigationPath = [groupKey, teamKey];
    updateUrl(navigationPath);
    render();
  }

  function navigateToSubTeam(groupKey, teamKey, subTeamKey) {
    navigationPath = [groupKey, teamKey, subTeamKey];
    updateUrl(navigationPath);
    render();
  }

  function navigateToTopLevel() {
    navigationPath = [];
    updateUrl(navigationPath);
    render();
  }

  // Handle browser back/forward buttons
  window.addEventListener('popstate', (event) => {
    if (event.state && event.state.navigationPath !== undefined) {
      navigationPath = event.state.navigationPath;
    } else {
      // Parse from URL if no state (e.g., initial page load)
      const urlParams = new URLSearchParams(window.location.search);
      const teamParam = urlParams.get('team');
      if (teamParam) {
        try {
          navigationPath = JSON.parse(teamParam);
        } catch (e) {
          navigationPath = [];
        }
      } else {
        navigationPath = [];
      }
    }
    render();
  });

  // ========== INITIALIZATION ==========
  document.addEventListener('DOMContentLoaded', () => {
    // Check for team parameter in URL
    const urlParams = new URLSearchParams(window.location.search);
    const teamParam = urlParams.get('team');
    
    if (teamParam) {
      try {
        const teamPath = JSON.parse(decodeURIComponent(teamParam));
        if (Array.isArray(teamPath) && teamPath.length > 0) {
          // Validate the path exists in organizationData
          let valid = true;
          if (teamPath[0] && !organizationData[teamPath[0]]) valid = false;
          if (valid && teamPath[1] && !organizationData[teamPath[0]]?.teams?.[teamPath[1]]) valid = false;
          if (valid && teamPath[2] && !organizationData[teamPath[0]]?.teams?.[teamPath[1]]?.subTeams?.[teamPath[2]]) valid = false;
          
          if (valid) {
            navigationPath = teamPath;
          }
        }
      } catch (e) {
        // Invalid JSON, ignore
      }
    }
    
    // Set initial history state so back button works from first navigation
    updateUrl(navigationPath, false);
    
    render();
  });
</script>
</body>
</html>
